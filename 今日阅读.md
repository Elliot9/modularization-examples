9.1 【今日阅读】https://lobste.rs/s/ksf9t0/amd_open_source_gpu_kernel_driver_above_5 Device Simplicity Metric, the shorter the driver, but the longer the range of configuration parameters and the more difficult its initialization, the more complicated the device is internally, relative to the driver’s complexity.

8.31 -【今日阅读】https://newsletter.pragmaticengineer.com/p/developer-productivity-a-new-framework We can gather fast, accurate data with surveys: people can tell us about their work experience and systems much faster than we can typically instrument, test, and validate system data.

8.30 【今日阅读】https://newsletter.pragmaticengineer.com/p/measuring-developer-productivity The consultancy giant has devised a methodology they claim can measure software developer productivity. But that measurement comes at a high price – and we offer a more sensible approach. Part 1.

8.29 【今日阅读】https://milen.me/writings/premature-optimization-universally-misunderstood/ If you want to have fast software, you must think about performance from day one. This includes thinking about the tech stack, the architecture, the data access patterns, the data dependencies, the networking and how it all fits together.

8.28 【今日阅读】https://hygger.io/blog/software-estimates-explored-explained-and-debunked/ 5 Laws of Software Estimates – Explored, Explained and Debunked

8.27 【今日阅读】https://old.reddit.com/r/webdev/comments/1613yqj/as_i_get_older_i_just_dont_care_about_new/ As I get older, I just don't care about new technology

8.26 【今日阅读】https://htmx.org/essays/no-build-step/ Why htmx Does Not Have a Build Step

8.25 【今日阅读】https://www.mattduck.com/2021-04-a-philosophy-of-software-design.html Philosophy of Software Design

8.24 【今日阅读】https://jmmv.dev/2023/08/costs-exposed-monorepo-multirepo.html What’s not so obvious—and what the objectors are missing—is that these maintenance costs exist in multirepo environments too. The difference is that, in multirepo setups, these costs fly under the radar because they are smeared across every repo. When taken individually, the costs seem insignificant, but in unison, they make a taxing impact on every team member.

8.23 【今日阅读】https://lukeplant.me.uk/blog/posts/no-one-actually-wants-simplicity/ The reason that modern web development is swamped with complexity is that no one really wants things to be simple. We just think we do, while our choices prove otherwise.

8.22 【今日阅读】https://medium.com/source-and-buggy/do-one-thing-and-do-it-well-886b11a5d21 Let’s assume Kernighan and Pike were right about at least one thing: that this software bloat is a problem. Massive apps are hard to learn, hard to use, and buggy as hell. Some of this is a UX problem, but most of it is actually a symptom of the developer experience.

8.21 【今日阅读】https://cohost.org/tef/post/2503472-complex-simple-good ask programmer for very general advice, they might say "learn to avoid complexity" or "embrace simplicity". the only problem? it's really bad advice. not to be all "conservation of energy" here but when someone tells you they've eliminated complexity, it usually means the complexity is now someone else's problem.

8.20 【今日阅读】https://www.dancowell.com/breaking-the-rules/ When I took over the team, they were in month 8 of a 3-month project to relaunch the company's ecommerce website. After 2 months leading the team, I decided to scrap it and start over. This is the story of how and why, and whether it all worked out.

8.19 【今日阅读】https://luispcosta.com/managing-small-team Get to know everyone, and take note of what should change and why (if anything)

8.18 【今日阅读】https://arxiv.org/pdf/2307.12469.pdf 我们的研究表明:1)基于大语言模型的生成已显示出实用性。64%的问题可以完全自动解决,如果手动语义验证器合并在内,这个数字会提高到91%。此外,生成的驱动程序与行业中常用的驱动程序具有竞争力的性能;2)大语言模型在生成需要复杂API使用细节的模糊驱动程序时存在困难。三个关键设计可以提供帮助:重复查询、带示例查询和迭代查询。组合使用它们是一个优异的策略;3)仍有很大的改进空间,如自动语义正确性验证、API使用扩展和语义表生成。

8.17 【今日阅读】https://prefix.dev/blog/launching_pixi A pixi.toml project file is similar in spirit to a Cargo.toml or pyproject.toml file. Platform specific dependencies are read from the checked-in lock-file (Python, compilers, whatever the project needs). Dependencies are downloaded and installed into a project specific virtual environment. The environment is activated and the cross-platform command is run (this uses Deno task shell)

8.16 【今日阅读】https://queue.acm.org/detail.cfm?id=3595878 This paper provides a practical framework for understanding DevEx, and presents a measurement framework that combines feedback from developers with data about the engineering systems they interact with. These two frameworks provide leaders with clear, actionable insights into what to measure and where to focus in order to improve developer productivity.

8.15 【今日阅读】https://arxiv.org/pdf/2308.04748.pdf 使用 StarCoder 不断生成新的 program 来达到 fuzz test 的目的。为了避免手写 prompt，使用 gpt-4 来阅读被测应用的文档，自动生成 StarCoder 的 prompt。

8.14 【今日阅读】https://lobste.rs/s/p3ftiy/tailwind_death_web_craftsmanship As a mostly backend engineer that has reached to boostrap, bulma and similar tools in the past, I don’t think the rationale is necessarily considering front end as a lesser discipline but rather as another complicated discipline in its own right, one that it would take a equal or more amount of time to master. They know they cannot produce professional grade interfaces, but they still need or want to put something together (for the purposes of a personal project, a non-customer facing tool at work, etc.). Those tools allow them to do that passably with a similar amount of effort as learning a new library, which is convenient.

8.13 【今日阅读】https://news.ycombinator.com/item?id=37091983 When complexity leaps are on the table, there’s usually also an opportunity to squeeze some extra juice out of the system you have. By tweaking the workload, tuning performance, or supplementing the system in some way, you may be able to add months or even years of runway. When viable, these options are always preferable to building out a next-gen system.

8.12 【今日阅读】https://corrode.dev/blog/illegal-state/ If you've worked with Rust for a while, you've probably heard the phrase "making illegal states unrepresentable". It's a phrase that's often used when people praise Rust's type system. But what exactly does it mean? And how can you apply it to your own code?

8.11 【今日阅读】https://twitter.com/0zne/status/1689644496227864576 Do we still need Product Managers?
stripe’s zero-PM strategy lean toward a « no » ❌
Enters Engineering-Driven Development ↓

8.10 【今日阅读】https://two-wrongs.com/retro-prompts.html Sometimes explicit questions elicit answers that people don’t think of on their own. This article lists a set of questions I’ve found to be useful when holding development retrospectives, divided into three categories.

8.9 【今日阅读】https://daedtech.com/5-things-ive-learned-in-20-years-of-programming/ 5 Things I’ve Learned in 20 Years of Programming

8.8 【今日阅读】https://utcc.utoronto.ca/~cks/space/blog/sysadmin/LogMonitoringTarpit  In other words, problems that happen, that you care about, and probably that you can do something about. If a problem was probably a one time occurrence or occurs infrequently, the payoff from automated log monitoring for it can be potentially quite low (you can see this as an aspect of how alerts and monitoring can never be comprehensive).

8.7 【今日阅读】https://benhoyt.com/writings/name-before-type/ Name before type: why ‘age int’ is better than ‘int age’

8.6 【今日阅读】https://gitlab.com/dahjelle/notes-from-the-programmers-brain/-/blob/main/README.md The main idea is to understand how your brain works, so you can understand its strengths and weaknesses, using its strengths and compensating for its weaknesses.

8.5 【今日阅读】https://loup-vaillant.fr/articles/physics-of-readability to efficiently grow and maintain programs, code that is read together should be written together. Put another way, code that is written apart should not have to be read together. I like to call this rule “code locality”. It’s a simple rule, but we can derive quite a few guidelines from it.

8.4 【今日阅读】https://about.codecov.io/blog/codecov-is-now-open-source/ Codecov makes it easy to see absolute coverage and coverage changes overlayed with your source code, making it even easier to identify needed test areas.

8.3 【今日阅读】https://thunderseethe.dev/posts/whats-in-a-module/  Modules depending on other modules is core functionality of any module system. It informs a lot of decisions in the rest of the system implementation. 
* Weak - A module must have all dependencies available before it can start compilation
* Strong - A module can be compiled without its dependencies, and its dependencies can be provided later
Based on the definition alone, Strong Modules sound better. Why would we want to wait on our dependencies if we don’t have to? The answer is complexity. Weak Modules are, historically, much simpler than Strong Modules both to use and implement. 
Packaging is clearly vital, but languages don’t use the module system to do it. They all invent ad hoc methods to handle packaging. So the system has Weak Modules for namespacing and makes something else up for packages, calls it a compilation unit, JAR, or something else programmers hate.

8.2 【今日阅读】https://lobste.rs/s/frgf9r/throw_away_your_first_draft_your_code Where a new system concept or new technology is used, one has to build a system to throw away, for even the best planning is not so omniscient as to get it right the first time. Hence plan to throw one away; you will, anyhow.

8.1 【今日阅读】https://danluu.com/testing/ 这篇文章讨论了软件测试中的一些观点,主要比较了软件测试和硬件测试的差异。文章的主要观点包括:

1. 软件测试中大部分测试工作来自手写测试,而在硬件测试中手写测试只占很小的比例。

2. 随机测试在很多情况下可以高效地找到bug,但软件项目很少采用。文章建议可以考虑使用一些现有的随机测试框架。

3. 基于覆盖率的测试如AFL也很有效,但类似思想很少应用在单元测试中。作者自己做了一个基于覆盖率的单元测试的原型。

4. 硬件测试会在成千上万的机器上运行测试,而软件测试倾向于限制单个测试的运行时间。考虑到机器成本低廉,软件项目也应该考虑持续运行自动化测试。

5. 硬件项目的测试文化更注重发现所有重要bug,而软件项目的文化更倾向于接受有bug逃逸。这也影响着测试方法的选择。

6. 软件测试者应该改变仅仅依赖手工测试案例的思维定势,多考虑采用自动化随机测试等方法。

7.31 【今日阅读】https://tomasp.net/blog/2023/vague-spaces/ "Vague space" 是一个城市规划和建筑理论中的概念,指的是在城市中那些没有明确用途的被遗弃的空间。这篇文章探讨了程序和编程系统中是否也存在类似的 "vague space"。

文章总结了城市中的 vague space 的几个特征:

- 它们往往源自历史,是过去用于某些目的但现在不再需要的空间。

- 它们存在于城市不同区域或功能的交界处,比如工业区和住宅区之间。

- 它们是精心设计的有秩序空间的副产品,存在于这些有秩序空间的边界。

- 它们具有多重意义,既包含旧的使用痕迹,也适应新的非正式用途。

文章认为软件系统中也存在类似的特征:

- 遗留代码往往具有看不懂的旧逻辑,需要各种封装来与新系统集成。

- 微服务架构中的各服务之间就需要大量粘合代码进行集成。

- 越模块化的系统需要的各模块之间进行协调的糊涂代码就越多。

- 代码可从多个角度理解,程序员和用户的视角就不同。

所以 urban vague space 为思考软件设计提供了一些有启发性的类比。但是城市空间和程序空间有根本区别,城市空间是固定的,这一点值得注意。总体来说,从其他领域借用思考方式还是可以给我们提供一些新的视角的。

7.30 【今日阅读】https://www.hillelwayne.com/post/problems-with-the-4doc-model/ If we zoom out to programming languages (PLs), the 4doc model breaks down entirely. If you look at the Python docs, the tutorial section needs to also explain and reference, and the references are both explanation and how-to. Language concept maps are just too dense to separate.

7.29 【今日阅读】https://research.nccgroup.com/2023/07/20/tool-release-cartographer/ Cartographer simplifies the complexities of reverse engineering by allowing researchers to visually observe which parts of a program were executed, obtain details about each function’s execution, compare different runs of the same program, and much more.

7.28 【今日阅读】https://martypc.blogspot.com/2023/06/hardware-validating-emulator.html?m=1 In the emulation world, there are a few different ways to determine if your emulator is accurate.

7.27 【今日阅读】https://zhuanlan.zhihu.com/p/646163380 只会调用 transformers 库，对于学会写 runner 帮助是不大的。要写 runner，我们要打开黑盒子，把 transformers 库的依赖去掉，只依赖 pytorch 实现一遍 Llama 模型。然后就发现

* transformers 库包含了训练代码，包含了批量代码，包含了kv缓存等等功能。这些功能会极大影响初学者的阅读理解
* 一个变量名反复更新，比如 hidden_value，你都搞不清当前里面放的是啥了
* tensor 从名字看不出来这个 tensor 的 shape 和内容是什么

经过几天的努力改写成了一份极简代码，这是一张自动打日志记录下来的真实运行时 tensor 之间数据流。我们要跑的就是这么一个数据流。我们移植到其他硬件上，也是对比这个数据流是不是一致。

7.26 【今日阅读】https://rust-analyzer.github.io/blog/2023/07/24/durable-incrementality.html 这篇文章描述了 Salsa (一个由 rust-analyzer 使用的增量计算引擎)中实现的一种优化技术——durability 系统。主要内容如下:

- Salsa 通过记录函数调用之间的依赖关系来构建一个调用图。当输入变化时,Salsa 可以根据调用图判断哪些查询需要重新运行。

- Salsa 实现了两个额外的优化:early cutoff 和 laziness。early cutoff 可以重用一些依赖被修改输入的查询的结果,如果查询结果并没有实际改变。laziness 是指直到一个查询结果被要求时,才去追踪修改导致的失效信息。

- 但是当输入变化很小时,还是需要遍历整个调用图去更新版本号,这很耗费时间。

- durability 系统将查询区分为更持久和更易变的,Salsa 可以相应优化。标准库相关的查询标记为持久,用户代码相关的标记为易变。

- 实现上,使用版本向量而不是单个版本号。输入也标记不同的持久性级别。更新时根据输入持久性级别决定更新哪些版本号。查询时检查版本向量对应级别的版本号。

- 这样就可以避免输入变化只影响用户代码时,也检查标准库相关查询的问题。优化了性能。

7.25 【今日阅读】https://lobste.rs/s/hqchwu/seriously_you_should_be_having_fun The author leads with “People working in other industries should probably not be miserable at work either, but that is not the concern of this article”. About that:

I spent my 20s working almost-min-wage jobs in kitchens and grocery stores, working as many as 3 jobs (opening + prep work in a cafe in the early morning, cook in a restaurant in the afternoon and evening, and bus dishes on the weekend) and various side hustles to pay for a small room in a crowded house in South Berkeley (~approx 11 other people were living there), with not much hope in sight for anything different.

Sometimes nowadays I find myself getting frustrated with e.g. some of the nasty proprietary or legacy tech I have to work or interface with. But while this work can sometimes feel like slogging through filth, I’ve worked jobs where I literally had to slog my way through actual filth – and this is very far from that. As a knowledge worker, you generally have autonomy and respect and flexibility that is completely unheard of to even a lot of white collar workers, let alone folks toiling away doing physically demanding work for minimum wage. Not to mention you probably won’t deal with the kinds of psychological abuse and unsafe conditions that are part and parcel with many of those lower-wage jobs

Which isn’t to say that tech workers shouldn’t aim to improve their conditions further or try to have more fun at work or that we should put up with bullshit simply because others have it worse – It’s essential that we protect what we have and improve it and even enjoy ourselves. But I do think that tech workers often miss how dire things are for other folks, especially folks working low-wage, manual jobs, and it would be nice to see more recognition of the disparity in our circumstances

7.24 【今日阅读】https://encore.dev/blog/building-for-failure Uncovering hidden dangers when designing Event-Driven Systems

7.23 【今日阅读】https://ferd.ca/embrace-complexity-tighten-your-feedback-loops.html  "Embrace Complexity; Tighten Your Feedback Loops

7.22 【今日阅读】https://lobste.rs/s/vpqlh9/rethinking_infrastructure_as_code_from “Infrastructure as Code” even the best implementations I’ve seen kind of suffer from the same issues:

Feedback loops are long, and “runtime” exceptions are common.
Modularity rarely, if ever, actually exists and when it does it’s a painfully leaky abstraction. (Like a tediously written 1:1 copy of every single redis.conf parameter into a text templated yaml file)
Configuring code for multiple environments (example: {dev,staging,prod}x{pci,non-pci}x{country1, country2} almost always ends up distressingly ugly.

7.21 【今日阅读】https://blog.europython.eu/kraken-technologies-how-we-organize-our-very-large-pythonmonolith/  Kraken Technologies: How we organise our very large Python monolith

7.20 【今日阅读】https://buttondown.email/hillelwayne/archive/more-software-projects-need-defenses-of-design/ This document explains why SimPy is designed the way it is and how its design evolved over time. This is great! More projects need this!

7.19 【今日阅读】https://news.ycombinator.com/item?id=36729377 	Life After Coding: Becoming a Mentor

7.18 【今日阅读】https://news.ycombinator.com/item?id=36747052 What makes developers productive?

7.17 【今日阅读】https://news.ycombinator.com/item?id=36746014 6 days to change 1 line of code (2015)

7.16 【今日阅读】https://encore.dev/blog/eda-business-case Making a Business Case for an Event-Driven Architecture

7.15 【今日阅读】https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2023/ISSTA-tool.pdf  RustSmith tool generates random but valid Rust programs to test compilers like rustc in a differential testing approach. The validation lies in checking that different compiler versions or settings compile the same random program to produce the same output. Any differences in output would indicate a potential compiler bug.

7.14 【今日阅读】https://blog.testdouble.com/posts/2023-07-12-the-looming-demise-of-the-10x-developer/ 从软件行业两代程序员的差异出发,探讨了“热情”“工匠精神”“10倍程序员”等在业内颇受争议的话题。作者通过代际差异的视角,分析这些话题中的矛盾与冲突根源,让我们以新的角度思考这些争议。

7.13 【今日阅读】https://jcs.org/2023/07/12/api 不要太自由地接受所有请求,否则将来可能需要向后兼容不规范的请求。但是也不要太死板,可在一定程度上容忍不规范的请求。

7.12 【今日阅读】https://mp.weixin.qq.com/s/SV8Mu0TaOYHlDFInuzZfmQ 基于Go语言的滴滴DevOps重塑之路

7.11 【今日阅读】https://bpapillon.com/post/feature-flags-theory-vs-reality/ Due to these shortcomings, the conventional wisdom has always been that feature flags should be short-lived and kept to a minimum

7.10 【今日阅读】https://registerspill.thorstenball.com/p/the-messy-page Give me a messy project instead.

Something that we already know kinda works but that needs to be extended or scaled or refactored or tested or optimized or ported or shipped. That’s the good stuff, that’s where the fun starts.

7.9 【今日阅读】https://github.com/obi1kenobi/cargo-semver-checks/tree/main/src/lints Lint your crate API changes for semver violations. cargo-semver-checks uses the rustdoc tool to analyze the crate's API. 

7.8 【今日阅读】https://www.emergetools.com/deep-dives/threads There's only so much we can gather looking at public Meta builds, but it looks like Threads is heavily borrowing from Instagram on both platforms. Will be interesting to see if that changes.

7.7 【今日阅读】https://andydote.co.uk/2023/07/06/observability-driven-ci/ Tracking where the time goes in your CI pipeline is an important step towards being able to make it go even faster. Up until somewhat recently, the only way of tracking how long tasks took in CI was either hoping people had wrapped all their commands in time ..., or by reading a timestamped build log and calculating the difference between numbers. Which isn’t great or fun, if we’re being honest.

What if we could create graphs of what parts of the build took time? Something like this?

7.6 【今日阅读】https://lobste.rs/s/u5ddne/programming_computing_bloggers_how_do Programming and computing bloggers: How do you decide what to write about?

7.5 【今日阅读】https://lobste.rs/s/stacig/elixir_type_system_updates_moving_from 又一个添加了静态类型检查的动态类型语言，说明了动态类型的不得人心

7.4 【今日阅读】https://github.com/fabianlindfors/reshape Reshape works by creating views that encapsulate the underlying tables, which your application will interact with. During a migration, Reshape will automatically create a new set of views and set up triggers to translate inserts and updates between the old and new schema.

7.3 【今日阅读】https://xata.io/docs/concepts/how-it-works A database in Xata can have multiple branches, which are first-class citizens in the API. Branches are full logical databases that might or might not exist on the same set of physical instances. When you start a new branch from an existing one, the schema is copied, but the data is not automatically available in the new branch. As you create a development branch from a production branch, you can copy and sanitize parts of the data or initialize the branch with test data.

7.2 【今日阅读】https://lobste.rs/s/m7igmh/commonjs_is_hurting_javascript When I was getting started with TypeScript (and node.js) a year ago, I found it a pretty delightful developer experience except for modules. Especially since I needed my code to work on both front and back end. To this day I don’t like to touch those magic declarations in .tsconfig files — I got them to work somehow, but I don’t know exactly what they do, and looking at them makes my stomach hurt.

7.1 【今日阅读】https://www.softwareatscale.dev/p/quadratic-ci-cost-growth A less obvious aspect of CI cost is that, in some cases, it can increase at a quadratic rate over time. John Micco, the ex lead of the Google Test Automation Platform group, mentioned that Google would spend more on CI than the rest of its compute combined if it didn’t introduce serious optimizations along the way.

6.30 【今日阅读】https://lobste.rs/s/bqqzyh/coroutines_make_robot_code_easy Coroutines make robot code easy

6.29 【今日阅读】https://cohost.org/tef/post/1764930-how-not-to-write-a 文章中提到了几个不使用消息队列的原因:

消息队列通常没有反压力机制,无法告诉生产者减慢发送速度。这可能导致队列大小失控并耗尽磁盘空间。

消息队列通常具有持久性,无法丢弃消息。这使得重置系统状态变得困难。

消息队列通常无法限制队列大小。这可能导致队列增长失控。

消息队列不适合可靠性要求高的系统。消息可能会丢失,导致任务失败。需要人工干预来修复。

消息队列不适合任务级并行性。一个失败的任务可能会阻塞队列,影响其他任务。

消息队列通常难以调试和监控。难以确定系统中正在运行的进程,或某个任务失败的原因。

消息队列通常需要人工操作来恢复失败的任务和丢失的消息。这增加了运维成本。

相比之下,使用数据库跟踪状态和调度程序分配任务的方法具有以下优点:

可以实现反压力,限制待处理任务数量。

可以丢弃消息和重置系统状态。

具有内置的任务级错误处理和重试逻辑。一个失败的任务不会影响其他任务。

容易监控和调试。可以看到每个任务的状态和元数据。

系统始终处于恢复状态,可以自动重启失败或过期的任务。不需要人工操作。

易于扩展,可以添加更多状态和元数据。

更不容易在半夜叫醒运维人员。系统更加可靠和健壮。

所以,总的来说,使用消息队列的方法虽然简单,但难以构建一个可靠和健壮的系统。跟踪状态和使用调度程序可以解决许多消息队列无法解决的问题。

6.28 【今日阅读】https://lobste.rs/s/ifaar4/grug_brained_developer this collection of thoughts on software development gathered by grug brain developer

6.27 【今日阅读】https://www.amazon.com/dp/B0BW38DDBK who would have ever thought we need 267 pages about initializing variables/objects

6.26 【今日阅读】https://news.ycombinator.com/item?id=36465220 This may be overly negative to a whole field, but I sometimes feek the platform teams add more hurdles than "stability and velocity".
At places with basically no platform team, no advanced cloud setup etc, I as a dev could understand everything, and deploying mostly meant getting my jar file or whatever running on some ec2 instance.

Now I need to write a dockerfile, loads of manifests, know about ingresses, use whatever custom tooling and abstractions they've built on top of the cloud provider.

And what used to be a single guy is now a huge team just adding more complexity. And I'm having a hard time understanding if it's worth it, or just a cost sink.

6.25 【今日阅读】https://www.youtube.com/watch?v=2xC-d4rXT0k In this episode, we hear from David Fowler about his worst practice in software development: he can't use a template, scaffolding, or snippets without spending countless hours understanding why every line of code needs to be there.

6.24 【今日阅读】https://kind.engineering/ So I’d like to leave you with a simple question to get you thinking about kindness in your own teams, in your own companies:

How can you be kinder?

6.23 【今日阅读】https://buttondown.email/hillelwayne/archive/agile-is-people-the-rest-is-commentary/ Agile is people, the rest is commentary

6.22 【今日阅读】https://jordankaye.dev/posts/flexible-systems/ Thus my assertion: whether you’re working with people or with technology, your ability to change decisions in the future will often outweigh the importance of the decisions themselves.

6.21 【今日阅读】https://vllm.ai/ PagedAttention是一种新的注意力算法,它可以有效地管理注意力键和值。PagedAttention将注意力键值缓存分成块,每个块包含固定数量的令牌的键和值。在注意力计算期间,PagedAttention内核可以高效地识别和获取这些块。

因为块不需要在内存中连续,所以我们可以像操作系统的虚拟内存一样更灵活地管理键和值:可以将块视为页面,令牌视为字节,序列视为进程。序列的连续_逻辑块_映射到非连续的_物理块_,通过块表进行映射。物理块根据需要在生成新令牌时分配。

PagedAttention的另一个关键优点是高效的内存共享。例如,在_并行采样_中,多个输出序列从相同的提示生成。在这种情况下,用于提示的计算和内存可以在输出序列之间共享。PagedAttention通过其块表自然地启用内存共享。类似于进程如何共享物理页面,PagedAttention中的不同序列可以通过将其逻辑块映射到相同的物理块来共享块。为了确保安全共享,PagedAttention跟踪物理块的引用计数,并实现_写时复制_机制。

PagedAttention的内存共享大大减少了复杂采样算法的内存开销,例如并行采样和束搜索,将其内存使用量减少了高达55%。这可以将吞吐量提高高达2.2倍。这使得这样的采样方法在LLM服务中变得实用。

PagedAttention是vLLM的核心技术,vLLM是我们的LLM推理和服务引擎,支持各种模型,性能高且接口易于使用。有关vLLM和PagedAttention的更多技术细节,请查看我们的GitHub仓库,并密切关注我们的论文。

6.20 【今日阅读】https://www.youtube.com/watch?v=PvSpyhm6TUU 
抽象有助于我们获得更广泛的视角,让我们能够包括更多的例子并在不同的情况之间建立更多的联系。它可以深入理解事物的本质原因。
Abstraction helps us gain a broader perspective by allowing us to include more examples and make more connections between different situations. It leads to deeper understanding by getting to the heart of why things are the way they are.

抽象可以让我们看到事物之间的相互联系。例如,恶性循环通常涉及相互强化的感觉和行动。我们可以考虑如何打破这些循环。
Abstraction allows us to see the interconnectedness between things. For example, vicious cycles often involve feelings and actions that reinforce each other. We can think about how to break these cycles.

抽象有助于我们理解事物之间的关系。我们可以通过关注关系而不是内在特征来获得见解。例如,我们可以通过观察人与人之间的关系来更好地理解一个人。
Abstraction helps us understand relationships between things. We can gain insight by focusing on relationships rather than intrinsic characteristics. For example, we can understand people better by looking at their relationships.

抽象可以让我们在不同的情况之间进行切换,从不同的角度看问题。这可以帮助建立同情心,因为我们可以理解处于不同位置的感受。例如,我们可以在感觉被剥夺权利和拥有特权之间进行切换。
Abstraction allows us to pivot between different situations and see things from different points of view. This can help build empathy as we understand what it's like to be in different positions. For example, we can pivot between feeling underprivileged and privileged.

通过抽象思维进行高维思维可以简化复杂的情况。例如,偏好通常是二维的,而不是非此即彼。我们可以通过将事物框定为零和游戏而陷入一维。
Thinking in higher dimensions via abstraction can simplify complex situations. For example, preferences are often two-dimensional rather than either-or. We can get stuck in one dimension by framing things as zero-sum games.

抽象和逻辑可以与同情心形成一个良性循环,帮助我们理解他人并采取行动。我们应该追求“智慧”——使自己和他人受益。
Abstraction and logic can create a virtuous cycle with empathy, helping us to understand others and take action. We should aim for "intelligence" - benefiting ourselves and others.

要教授抽象概念,可以使用开放性的动手项目,让学生探索和发现见解,而不是追求唯一的“正确”答案。让学生写故事来表达抽象的想法。
To teach abstraction, use open-ended, hands-on projects where students can explore and discover insights, rather than aiming for a single "right" answer. Have students write stories to convey abstract ideas.

我们可以通过找到共同点和理解基本的分歧来达到不同信念的人。关注阐明而不是过于苛刻。所有的比喻都不完美,所以我们应该根据上下文考虑事物在何种意义上是类比的或不同的。
We can reach people with different beliefs by finding common ground and understanding fundamental points of disagreement. Focus on being illuminating rather than pedantic. All analogies are imperfect, so we should consider in what senses things are analogous or different depending on context.

6.19 【今日阅读】https://lobste.rs/s/iozq2j/legend_x86_cpus_decode_instructions_into 本文探讨了x86 CPU在内部是否真的会将指令解码成RISC形式的说法。作者分析了从Intel P6微体系结构到目前的设计,对一段简单的循环代码是如何处理的。

P6微体系结构(1995年Pentium Pro首次推出)的确将指令解码成RISC形式的微操作。例如add [edx], eax这条指令被解码成4个微操作。这比RISC-V的相同功能的指令数还要多,这是由于P6微体系结构的设计缺陷导致的。

Pentium M(首次在Pentium M处理器中推出)引入了微操作融合,可以将某些指令解码得到的微操作对融合在一起。对于add [edx], eax这条指令,Pentium M只需要3个微操作,与RISC-V代码完全匹配。

Core微体系结构(首次在2006年的Core 2处理器中推出)进一步提高了微操作融合的能力。对于add [edx], eax这条指令,Core只需要2个微操作,但这2个微操作已经不太像RISC指令了。

Sandy Bridge微体系结构(2011年首次推出)引入了分支融合,可以将某些运算指令与后续的条件跳转指令融合。对于示例代码中的循环,Sandy Bridge只需要4个微操作,与x86指令数相同。

其他x86微体系结构,如AMD的设计和Intel Atom,在内部从未将add [edx], eax这样的指令解码成多个微操作。

所以,x86 CPU将指令解码成RISC形式的说法只在某种程度上是正确的。P6微体系结构的确如此,但后续的改进使得微操作与RISC指令的对应关系变得复杂,有的微体系结构家族从未采取过这样的方式。所以,这个说法对所有的x86 CPU来说都不完全正确。
The legend of "x86 CPUs decode instructions into RISC form internally"
14 comments


6.18 【今日阅读】https://lobste.rs/s/yfy98y/ikea_oriented_development I came for the title but I don’t see a lot of value in reiterating what we already know: less data is better, less external dependencies is better, having a clear API is good.

What I hoped the article would touch on is how we can apply Ikea’s simple, pragmatic, not-fancy-but-also-not-ugly philosophy to programming. Making informed decisions about tradeoffs between functionality, polishing and cost is still one of the biggest challenges in product development for me, and there is something about this that Ikea seems to get right.

6.17 【今日阅读】https://pboyd.io/posts/productivity-limit/ Block scheduling could make a comeback, as it begins to make sense when there’s scarcity. High GPU prices create similar incentives already, and who can say what time on the first practical quantum computers will cost.

6.16 【今日阅读】https://www.sebaslab.com/the-quest-for-maintainable-code-and-the-path-to-ecs/ 这篇文章的主要内容是:

    作者认为可维护的代码应该易于阅读、扩展和重构。可维护的代码通常属于不断演变和变化的代码库。像游戏服务这样的产品需要不断演变来吸引玩家,代码本身也会通过无数次迭代不断变化。仅凭编码指南和代码审查是不够的,要保证代码不会随着时间的推移变得难以管理。

    作者认为,面向对象编程中的数据封装对于抽象数据类型来说效果很好。你可以创建数据结构,提供公共函数来管理这个数据结构。封装可以很好地隐藏复杂性。但是,封装本身无法防止对象被误用。如果可以编写一个应用程序而不需要任何形式的对象间通信,我们就可以开发出完美封装的实体。如果我们还设计类来解决一个单一的问题,那么我们就会有一个可维护的代码库的完美场景。代码库将精简,模块化和完全解耦。

    作者认为,面向对象编程中对象通信的问题始终存在。无论是通过事件、消息、中介者还是其他方式,对象通信总是需要以某种方式意识到要与之通信的对象。对象通信是造成任何意大利面代码的原因。所有的抽象形式和相对良好的实践最终目的都是为了控制对象间的通信。

    作者认为,实体组件系统设计是开发更简单、更便宜的代码库的一种很好的范例。实体组件系统提供了开发大多数(如果不是全部)游戏相关行为的严格方向。实体组件系统很容易促进通过行为抽象的模块化,这导致SOLID原则的自然应用。

    作者试图理解SOLID原则(面向对象编程范例)是否也适用于实体组件系统范例。如果ECS用于编写ECS中心的应用程序,而不仅仅是需要“快速”的几个部分,我们需要一些指导方针来确保我们的代码

6.15 【今日阅读】https://news.ycombinator.com/item?id=26686770 On Cache Invalidation: Why Is It Hard?

6.14 【今日阅读】https://github.com/jakobkhansen/CCDetect-lsp 这是一个执行重复代码检测（也称为代码克隆检测）的LSP工具。此工具的目标是创建一个完全增量更新的静态分析工具，它在编辑器环境中提供实时的克隆检测。此工具利用树状结构的语法进行任意语言的增量解析，实现了快速的增量更新（在保存或每次按键时），甚至在非常大的代码库上。

6.13 【今日阅读】https://lobste.rs/s/vtghvu/why_not_tell_people_simply_use_pyenv 作者主要有两个原因建议Python用户避免使用诸如homebrew、pyenv、anaconda和poetry等工具：

1. 故障模式过于复杂：尽管这些工具被设计出来是为了简化Python的安装和包管理，但是它们带来的故障模式的数量和复杂性都很高。这些问题并不容易解决，特别是对于平均用户来说，他们可能没有足够的资源来处理这些故障​​。
2. 投资回报率较低：使用这些工具所带来的收益并不能抵消处理它们可能出现的问题所需的时间和精力。换句话说，虽然这些工具可能在某些情况下会有所帮助，但是由于它们可能引发的问题，所以使用它们的总体回报可能会变得较低​。

因此，作者倾向于推荐一种更简单、更直接的方式来解决Python包管理的问题，这种方式更注重于解决最常见的问题，而不是尝试去解决所有可能出现的问题。

6.12 【今日阅读】https://lobste.rs/s/vx8hbs/rust_module_system_encourages_poor Rust Module System Encourages Poor Practices (Comparing to Go)

6.11 【今日阅读】https://two-wrongs.com/handoff-waste-and-taylorism.html We can minimise handoff by keeping the four functions of responsibility, knowledge, action, and feedback together. For each product being developed, there should be exactly one person

6.10 【今日阅读】https://docs.google.com/document/u/0/d/1HB9CUfavNbeP1cU8QPl9kjYuiME2_90P5DDRjqxYyIo/mobilebasic#heading=h.j54phqvh6ubj SRE in the Real World

6.9 【今日阅读】https://www.toptal.com/software/creating-modular-code-with-no-dependencies Creating Truly Modular Code with No Dependencies

6.8 【今日阅读】https://www.infoq.com/articles/debugging-beneath-trusted-abstraction/ 作者的公司的支付平台的数据库集群遭遇了重大故障。他们不得不手动切换到一个副本来恢复服务。

他们花了两周的时间去调查和重现这次故障，以全面理解发生了什么并解决问题。他们使用Docker Compose环境来快速测试不同的假设。

他们将潜在问题缩小到了5个可能的调查路径。他们从“低挂的果实”开始——那些可能导致故障且调查工作量较小的问题。

他们深入研究Postgres内部机制，理解复制和预写日志（WAL）格式，以便重现他们看到的一个可疑的错误信息。这花了很多试错，但他们最终能够准确地重现了这次故障。

结果WAL数据的问题是一种误导。实际的问题是他们的Pacemaker配置和他们用于备份的“虚拟IP”之间的交互。他们的限制条件阻止了Pacemaker正确地故障转移。

他们从中得到的教训是，当出现协调故障时，简单的配置可能会导致灾难，自动化可能会侵蚀对系统的了解，测试环境可能无法完全匹配生产环境。

调试复杂问题的关键是坚持，质疑你的假设，有时还要在生产环境中调试。与社区中的其他人分享调试故事可以帮助所有人提高。

作者邀请读者分享他们调查过的有趣的bug的故事，使用标签 #MyDebuggingStatus。分享具体的经验可以帮助他人以一种正式的材料无法做到的方式学习。

6.7 【今日阅读】https://semgrep.dev/blog/2023/turbo-mode a fast linter compiled as wasm

6.6 【今日阅读】https://www.youtube.com/watch?v=02rkpTou3fs Worst Practices in Software Development 系列: Sean Taylor's notebooks are a mess

6.5 【今日阅读】https://lobste.rs/s/zftsuo/git_is_simply_too_hard_2020 

The amount of time I spent during my career helping people with Git or SQL issues is mind boggling. IMHO, this is not the fault of Git or SQL, it’s the fault of our industry.

If a carpenter didn’t know how to use a sawbench or a nailer, we would consider them a bad carpenter. But if a developer doesn’t want to learn the standard tool, and just want get their work done without learning how to master anything, this is somehow acceptable…

6.4 【今日阅读】https://mitchellh.com/writing/building-large-technical-projects 这篇博客是 Mitchell Hashimoto 对如何完成大型技术项目的个人见解。以下是主要的观点：

    项目启动：找到项目开始的地方可能是最难的部分。对于大型项目，你需要首先将其分解成可见的子项目。例如，如果你的目标是构建一个能运行 Neovim 的终端，那么你需要识别出构建这个终端所需的各个组件，如 GUI 的渲染、进程的启动、终端解析和状态管理等。然后，你可以选择一个可以独立构建并看到实际结果的子项目开始​1​。

    早期结果：早期的工作可能并不太可见，这使得看到具体结果变得困难。在这个阶段，自动化测试（尤其是单元测试）是一个非常好的工具，可以让你实际运行一些代码，并看到它是如何工作的​1​。

    冲刺到演示：早期子项目的目标不是建立一个完整的子组件，而是建立一个足够好的子组件，以便你可以继续下一个导向演示的工作。重要的是不要让完美成为进步的敌人。你要明确，你的目标是达到一个演示，而不是完美的产品​1​。

    为自己建设：如果你在做个人项目，那么应当尽可能快地使用你的软件，并且只在需要的时候构建你需要的功能。如果一个为你设计的产品对你自己都不管用，那么它很可能对其他人也不管用。因此，从演示到实际可用产品的最短路径，是只构建你认为需要的功能​1​。

6.3 【今日阅读】https://novalis.org/blog/2016-09-27-against-generality.html And this is why basically nothing is 20,000 lines of code, and if anything is 20,000 lines of code, it’s “by shaving off as many requirements of every imaginable kind as you can”.

6.2 【今日阅读】https://hackmd.io/@cflewis/Sk0gb9ILh On Software Dependency Engineering

6.1 【今日阅读】https://lobste.rs/s/wu1bo4/how_discover_all_data_sources_low_fuss_way How to discover all the data sources, low-fuss way

5.31 【今日阅读】https://blog.ploeh.dk/2023/05/29/favour-flat-code-file-folders/ Favour flat code file folders. People usually dislike that advice. How can I find anything?!

5.30 【今日阅读】https://www.joshwcomeau.com/career/clever-code-considered-harmful/ Clever Code Considered Harmful

5.29 【今日阅读】https://lobste.rs/s/tlau5r/names_are_not_descriptions_descriptions So, why do we have names? Because we store packages in indices with names for keys. Maybe we shouldn’t have package indices.
Maybe we shouldn’t have packages; this is a very tough concept but worth pondering. Quoting the question in its entirety:
Suppose that a programming language has modules, but does not have a notion of packages or other collections of modules. Which software engineering tasks are expensive or impossible without packages?

5.28 【今日阅读】https://blog.replit.com/super-colliding-nix-stores Replit has bet big on Nix because we believe in a future where developers are free from the drudgery of setting up their development and production environments. A world where onboarding a co-worker is as simple as forking a Repl. When you use Nix to describe your environment, you don’t have to redo your setup everywhere you want your code to work. As Mitchell Hashimoto, founder of Hashicorp, said: one big benefit is that once you adopt Nix, you can get a consistent environment across development (on both Linux and Mac), CI, and production.

5.27 【今日阅读】https://two-wrongs.com/event-sourcing-and-microservices-unix-style.html 这篇文章讲述了如何使用类Unix风格的思想来实现事件溯源和微服务架构。主要的思想是:

1. 高内聚和低耦合。这两个理念是软件工程中许多好的实践的基础,如单一职责原则、DRY原则、接口隔离原则等。高内聚的组件更易于理解,低耦合的组件可以独立运行和异步通信。 
2. 避免过度复杂化。实现微服务架构不一定需要复杂的工具和框架。简单的脚本和纯文本文件也可以实现同样的效果,除非你真的需要那些工具提供的功能。
3. 遵循Unix哲学。Unix哲学推崇“做一件事并把它做好”和“让程序协同工作”。这篇文章的例子演示了如何简单的脚本协同工作来实现一个小系统。
4. 事件作为不变的原子信息。事件不做任何假设,可以解耦组件。日志文件充当不变的事件来源。
5. 避免短暂的耦合。分析脚本和生成脚本被设计为独立运行,生成脚本不直接使用最新的数据来影响它的分布。这避免了两者之间的短暂耦合。

总的来说,这篇文章展示了如何根据Unix哲学来设计一个简单的系统,利用高内聚、低耦合和事件来实现松散耦合的微服务架构。
Event Sourcing and Microservices – Unix Style
Two Wrongs Event Sourcing and Microservices – Unix Style Home Tags Feed About xkqr.org Event Sourcing and Microservices – Unix Style by kqr , published 2023-05-11 Tags: meta_programming unix programmi


5.26 【今日阅读】https://chipsandcheese.com/2023/01/07/microbenchmarking-amds-rdna-3-graphics-architecture/ I’m guessing RDNA 3’s dual issue mode will have limited impact. It relies heavily on the compiler to find VOPD possibilities, and compilers are frustratingly stupid at seeing very simple optimizations. For example, the FMA test above uses one variable for two of the inputs, which should make it possible for the compiler to meet dual issue constraints. But obviously, the compiler didn’t make it happen. We also tested with clpeak, and see similar behavior there.

5.25 【今日阅读】https://thinkinglabs.io/articles/2023/05/02/continuous-code-reviews-using-non-blocking-reviews-a-case-study.html Whereas with blocking reviews, like Pull Requests, a redesign means a delay in delivery. With Non-Blocking Reviews we do not have that. Yet, to be honest, when I have to work with Pull Requests I frequently find myself accepting non-optimal designs to ensure the feature is delivered. But I suggest improving the design. Nevertheless, I always leave that decision to the person requesting the review to create empowerment.

5.24 【今日阅读】https://itnext.io/does-linq-to-monad-improve-code-readability-can-we-measure-that-b8afdac41a35 Let’s try come with a prompt so we can measure code readability.

5.23 【今日阅读】https://redd.one/blog/the-art-of-code-review The Art of Code Review

5.22 【今日阅读】https://mojodojo.dev/mojo_team_answers.html#what-makes-rust-c-compilation-slow What makes Rust/C++ compilation slow? Type system. you're creating all the llvm ir nodes ("LLVM") and then asking llvm optimization passes to delete them for you. It is far better to not generate it in the first place. Reasonable codegen is O(N^2) and worse in core algorithms like register allocation and scheduling.

5.21 【今日阅读】https://explosion.ai/blog/against-llm-maximalism 如果你想开发可靠和可扩展的系统,LLM本身并不是直接的解决方案。相反，作者建议将任务分解成一系列预测和生成步骤，将LLM视为系统中的另一个模块，并根据需要调用它。

5.20 【今日阅读】https://lobste.rs/s/dcqnkv/organize_business_logic_your_ruby_on Rails use at large seems to have converged on the “use-case controller” with “row-table as object” (row-table gateway) patterns, rather than the Active Record pattern. Procedural scripts and sub-procedures driving database data.

5.19 【今日阅读】https://www.se-radio.net/2023/05/se-radio-564-paul-hammant-on-trunk-based-development/ Paul Hammant, independent consultant, joins host Giovanni Asproni to speak about trunk-based development—a version control management practice in which developers merge small, frequent updates to a core “trunk” or main branch. The episode explores the technique in some detail, including its pros and cons and some examples from real projects, and offers suggestions on how to get started. The conversation touches on a set of related topics, including code reviews, feature flags, continuous integration, and testing.

5.18 【今日阅读】https://lobste.rs/s/aqez4c/how_are_nullables_different_from_mocks Yes, at the lowest level, a Nullable is a production module with an embedded Fake or Stub. Nullables have two big advantages over traditional Fakes and Stubs. 
* First is that you stub the third-party library, not your own code. Fakes and stubs are usually written as a replacement for your code. The Nullable approach means that your tests are running all the code you wrote, so you catch more errors when things change. 
* The other advantage of Nullables over traditional Fakes and Stubs is the emphasis on encapsulation. Although they’re implemented with an embedded Fake/Stub at the lowest level, the conception of the Nullable is that it’s “production code with an infrastructure off switch.”

5.17 【今日阅读】https://www.thecodedmessage.com/posts/async-colors/ Colored Is Good, Actually, and Rusty

5.16 【今日阅读】https://news.ycombinator.com/item?id=35935944 这段评论在讨论什么样的软件开发方法论比较好。具体来说:

作者提出的“假设驱动开发”方法论,意思是通过设想各种使用场景和数据输入来推导出适当的类型系统和业务逻辑。评论者kstenerud提出这个方法在需求变更时会很难应对,可能需要重构类型系统,所以仍需要测试来保证正确性。

其他评论者认为,如果类型系统设计得当,需求变更时可以更容易地扩展类型系统,并且编译器可以提示需要修改的地方。但typescript这样的强类型语言在超复杂的系统中还是会难以建立完备的类型系统。

有评论认为,除非是非常规范化和可预测的领域(如金融),大部分软件项目的需求实际上都是不断变化的,很难给出标准的“正确”定义。所以像作者提出的那种以“正确性”为目标的开发方法论,实际上并不实用。但某些团队和项目还是可以从中受益。

也有评论指出,真正的“根本原因”通常比作者举例中提到的更复杂。一个事件的起因通常不是单一的,而是多个因素的综合结果。

所以,总体来说,评论者认为软件开发的方法论选择还需要考虑很多方面,并不像作者所暗示的那么简单。需求和环境的复杂程度,团队实力等,都会对方法论的适用性产生较大影响。

5.15 【今日阅读】http://www.radicalsimpli.city/ What is Radical Simplicity? Radical Simplicity means having as few components and moving parts as possible. Reuse technology for different purposes instead of having a new moving part for each purpose. Instead of using Postgres as a database, Druid for an event store, Redis for caching, Rabbit MQ as a message queue and Elastic for fulltext search, use a hosted Postgres as a database, for fulltext search, html caching, publish/subscribe, and an event store with TimescaleDB.

5.14 【今日阅读】https://blog.ganssle.io/articles/2023/01/attractive-nuisances.html 大多数用户不会从头到尾完全理解你的文档和概念,然后使用你的软件解决问题——他们会使用软件尝试解决问题,然后寻找最简单的解决方案实施。在设计界面时,这一点很重要,因为很容易无意中创建吸引过失;如果有两种方法完成任务,一种简单看起来正确但细微错误,另一种正确但更复杂,大多数人会做错事。我博客的许多文章事后试图教育人们关于这些吸引过失,如pytz和utcnow()和utcfromtimestamp()的文章。

5.13 【今日阅读】https://justinblank.com/notebooks/characterizingtechdebt.html 技术债务是一个广泛使用但含义不明确的术语。最初,Ward Cunningham将其定义为采取迭代开发过程时的一个现象:由于需求和理解在不同阶段会发生变化,代码在某个时候无法完全匹配开发人员的理解,这需要额外的工作来修复,就像还债一样。但是,该术语的定义已扩展到涵盖任何开发人员不喜欢的代码,低质量代码,业余程序员编写的代码,不考虑软件架构的代码(所谓的“乱麻球”)以及静态分析工具标记的反模式代码。技术债务有几个维度:影响、修复成本和传染性。技术债务可以是:本地债务、胡迪债务、基础债务或数据债务。为了解决这个问题,应选择某些可衡量的东西来评估系统的质量。作者建议使用维护负载。维护负载是开发人员在非新增功能或删除功能的任务上花费的时间和精力。与业务人员讨论这个数字。如果我们有6名开发人员,但一半的工作是维护工作,那么我们的功能计划只能假定3名开发人员。业务人员认为工程师是昂贵的,所以这种框架可以激励他们帮助我们降低维护负载。

技术债务并不仅仅是糟糕的代码。它也不是维护工作或过时的依赖关系。相反,它涉及到为了短期利益而使未来的维护成本增加的有意识的选择。
“技术债务”这个短语应该是一个谈话的开始,而不是结束。考虑你的受众是谁,在使用任何技术术语之前,要正确理解它。

5.12 【今日阅读】https://www.thoughtworks.com/insights/podcasts/technology-podcasts/reckoning-with-the-force-conways-law 这篇文章提出了一些不寻常的观点:

1. 康威定律影响软件架构。组织的沟通结构会限制它产生的设计。换句话说,软件团队的组织方式会影响最终的软件架构。

2. 逆向康威机动利用康威定律的力量来取得想要的结果。通过调整软件开发的组织方式来产生理想的软件架构。

3. 随着时间的推移,组织方式和软件架构都在不断演变。你不能将两者分开考虑。要时刻牢记康威定律的存在,并善于利用它,而不是与之抗争。

4. 业务能力是稳定的,而实现会变化。业务能力涵盖人员、流程和工具(其中工具指软件),这些要素共同构成企业体系结构的稳定部分。

5. 远程工作会影响沟通模式和软件架构决策。远程工作虽然减弱了沟通,但也推动了组织方式和软件架构的变革。我们还需要更多时间来观察这些变化对不同组织的影响。

6. 要成为一名出色的软件架构师,你必须意识到康威定律的存在,并关注软件开发组织的设计。软件架构的演进同时也需要开发团队组织的演进。你必须同时关注这两个方面。

5.11 【今日阅读】https://lemire.me/blog/2023/04/27/hotspot-performance-engineering-fails/ that explain why companies do full rewrites of their code for performance: the effort needed to squeeze more performance from the existing code becomes too much and a complete rewrite is cheaper.

5.10 【今日阅读】https://autonomy.design/Part1/ConsistencyMetrics.html 所谓“阻断率”就是 https://en.wikipedia.org/wiki/Effect_system

5.9 【今日阅读】https://nathan-kim.org/writing/nixos-post-mortem The main issue, which many people have commented on, is that NixOS invented a programming language called Nix to manage the system, and that language is extremely frustrating. It is difficult to learn because there are relatively few guides available online to learn it, a compounding problem given Nix’s general difficulty arguably require more guides for it than other high-level languages. Some design decisions make the language aggravatingly confusing.4 And the language syntactically does not really resemble any popular high-level language.

5.8 【今日阅读】https://blog.testdouble.com/posts/2023-05-02-frictionless-developer-environments/ devenv and direnv
Frictionless developer environments
Reducing friction and pain points for new contributors can reduce your time-to-first-commit.

5.7 【今日阅读】https://testing.googleblog.com/2023/04/sensenmann-code-deletion-at-scale.html Automatically deleting code may sound like a strange idea: code is expensive to write, and is generally considered to be an asset. However, unused code costs time and effort, whether in maintaining it, or cleaning it up. Once a code base reaches a certain size, it starts to make real sense to invest engineering time in automating the clean-up process. At Google's scale, it is estimated that automatic code deletion has paid for itself tens of times over, in saved maintenance costs.

5.6 【今日阅读】https://lobste.rs/s/fsnvuu/even_amazon_can_t_make_sense_serverless Even Amazon can't make sense of serverless or microservices

5.5 【今日阅读】https://lobste.rs/s/etmmm5/moving_prime_video_service_monolith I think it’s easier to go from microservices to monoliths because coupling two systems is easier than decoupling them. Like a trivial optimization for this situation would be to colocate the services and eventually remove the “remote” from “remote procedure call” altogether. So in that sense microservices are “safer” in that if you want to back out it’s trivial.

5.4 【今日阅读】https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu WebGPU is the new WebGL. That means it is the new way to draw 3D in web browsers. It is, in my opinion, very good actually. It is so good I think it will also replace Canvas and become the new way to draw 2D in web browsers. In fact it is so good I think it will replace Vulkan as well as normal OpenGL, and become just the standard way to draw, in any kind of software, from any programming language.

5.3 【今日阅读】https://lobste.rs/s/ndkycy/why_split_lexing_parsing_into_two Why Split Lexing and Parsing Into Two Separate Phases?

5.2 【今日阅读】https://justsimply.dev/ Scan your technical writing for words such as easy, painless, straightforward, trivial, simple and just. Chances are your writing will be clearer as a result of removing them. Here’s a cleaned-up real life example, showing that the joy of the code can be better explained without all the “just”s and “simply”s.

5.1 【今日阅读】https://skeeto.s3.amazonaws.com/share/onward17-essays2.pdf  An Alternative History of Undecidedness: achieving debuggability and reliability through simplicity
and comprehensibility was central to the Unix philosophy. Somehow, modern implementations of C have diverged utterly from this. In the words of Linus Torvalds, they are adept at “turning [a] small mistake into a real and exploitable security hole”.

4.30 【今日阅读】https://lobste.rs/s/qxlh6m/native_implementation_mutable_value mutable value semantics is a nice middle ground between reference semantics and total purity.

4.29 【今日阅读】https://www.moderndescartes.com/essays/research_code/ The Three-Tier Codebase: Core, Projects, Experimental

4.28 【今日阅读】https://lobste.rs/s/ee4npn/gradle_still_sucks Gradle still sucks

4.27 【今日阅读】https://www.youtube.com/watch?v=w3WYdYyjek4 The speaker shares a "magic trick" for designing and building complex distributed systems more efficiently. The trick is referred to as "tiger style" and consists of three ideas that work together: seeing the whole picture, checking oneself before proceeding, and using a time machine to bring the future forward. By applying these ideas, the speaker's team was able to design and build a distributed financial accounting database called Tiger Beetle in less than three years, with a focus on mission-critical safety and performance. Tiger style challenges the idea of using popular tools and dependencies simply because they are popular, instead encouraging developers to choose tools based on quality. The speaker argues that having a hard problem to solve is a blessing, and that tiger style can help developers solve these problems more effectively. The talk includes a demo of the tiger style approach and concludes with the idea that using tiger style can help developers build systems they may have never thought possible before.

4.26 【今日阅读】https://ntietz.com/blog/distractions-cause-bad-code/ We are barraged by constant distractions, and they are degrading the quality of our work.

4.25 【今日阅读】https://www.appsmith.com/blog/monoliths-vs-microservices-1 When interviewing candidate software engineers, I always ask the question, “What will you do to improve Appsmith?” The all-too common response from candidates is, “I would make the Appsmith codebase microservice-oriented.”

4.24 【今日阅读】https://news.ycombinator.com/item?id=35676572 A colleague of mine talks about the Law of Conservation of Complexity. It boils down to "the complexity will have to go somewhere". My only hesitation with methods like this is it ends up splitting the business rules into two places, where one is sort of obscured.

4.23 【今日阅读】https://jimmyhmiller.github.io/empirical Q: Do you just hate empirical software studies? A: No. I have nothing against it at all. Studying the world is great. I just see a common implicit conflation of what science tells us is true and what we ought to do. These things are not one and the same and we should pay attention to that.

4.22 【今日阅读】https://people.inf.ethz.ch/wirth/Articles/LeanSoftware.pdf software developers should strive to create lean software that is simple, efficient, and easy to understand. While there are some potential downsides to lean software, such as a lack of features or reduced performance, Wirth believes that the benefits of lean software outweigh the drawbacks. Software developers should prioritize simplicity and efficiency when creating software, rather than trying to cram in as many features as possible.

4.21 【今日阅读】https://lobste.rs/s/pqwtxa/why_perl When a programmer writes a blog article “Why (language)?”, the answer is always and inevitably: “Because that’s the language that I know.” Everything else is a rounding error.

4.20 【今日阅读】https://tidyfirst.substack.com/p/90-of-my-skills-are-now-worth-0 to everyone say, “Yeah, but ChatGPT isn’t very good,” I would remind you that technological revolutions aren’t about absolute values but rather growth rates. If I’m big & you’re small & you’re growing faster, then it’s a matter of time before you surpass me.

4.19 【今日阅读】https://lobste.rs/s/higjju/building_15_year_old_software_with_nix I suppose the fundamental problem is that the Nixpkgs repo only contains the information for how to build one version of a package at any given time -namely, the latest version of the package that the maintainer has updated in the Nixpkgs repo. The author had to go back into the Git history to find the version they cared about, copy the file, and manually backport all the fixes for things that had been fixed in later versions of the Nixpkgs repo.

4.18 【今日阅读】https://www.youtube.com/@WorstPractices We've all heard enough of everyone's "best practices" in software development. What are the *worst* practices you follow?

4.17 【今日阅读】https://lobste.rs/s/iksbf4/alien_artefacts the biggest example of this that i can think of is google’s “gcl” or “borgcfg” (two names for the same config language). it’s also a lazily-evaluated language with dynamic scope and inheritance. i don’t think anybody knows a concise description of how it resolves symbols, including the team that owns it. it’s usually described by example in documentation, and forensically in postmortems

4.16 【今日阅读】https://apenwarr.ca/log/20201227 "Systems design" is a branch of study that tries to find universal architectural patterns that are valid across disciplines. https://apenwarr.ca/log/20230415 scientists absolutely bloody despise emergent complexity → systems design → magical thinking.

4.15 【今日阅读】https://registerspill.thorstenball.com/p/two-types-of-software-engineers The first type is very common. They are the reason everything is complex and fragile.

4.14 【今日阅读】https://devblogs.microsoft.com/cppblog/cmake-debugger-allows-you-to-debug-your-cmake-scripts-and-more/ 看了 cmake 的 debugger，不禁怀疑为什么需要 cmake，它并没有通过一门叫 cmake 的语言约束使得调试体验更好啊。

4.13 【今日阅读】https://spritely.institute/news/introducing-a-distributed-debugger-for-goblins-with-time-travel.html Debugging distributed programs is difficult, but we’ve been hard at work developing tools to make it easier

4.12 【今日阅读】https://buttondown.email/hillelwayne/archive/i-really-like-powershell/ You can also add new providers, which makes it possible to do things like mount a json file as a drive and modify it like it was a filesystem.

4.11 【今日阅读】https://lobste.rs/s/f61udz/modular_errors_with_rust_s_thiserror in a library, taking a proc macro dependency significantly restructures compilation graph for your consumer, and you, as a library, don’t want to force that. libraries should work hard on protecting their own abstractions. not a fan of using From even in applications, as it makes it harder to grep for origins of errors

4.10 【今日阅读】https://lobste.rs/s/pvrcob/on_endings_why_how_we_retired_elm_at So basically, “the benefits of using Elm didn’t weigh enough against the costs of integrating Elm with other systems”? Seems to me like a pretty decent example of why “Pinky & The Brain” systems seldom go anywhere

4.9 【今日阅读】https://v8.dev/blog/wasm-tail-call We are shipping WebAssembly tail calls in V8 v11.2! In this post we give a brief overview of this proposal, demonstrate an interesting use case for C++ coroutines with Emscripten, and show how V8 handles tail calls internally.

4.8 【今日阅读】https://lobste.rs/s/b0fkuh/build_faster_with_buck2_our_open_source Build faster with Buck2: Our open source build system

4.7 【今日阅读】https://lukeplant.me.uk/blog/posts/the-different-uses-of-python-type-hints/ When you use type hints in Python, you could be using them for one or more of at least 5 different things

4.6 【今日阅读】https://betterprogramming.pub/graphql-from-excitement-to-deception-f81f7c95b7cf Disclaimer: GraphQL is trendy, and you will find countless articles about how it’s amazing, but after three years of using it, I am a bit bitter and disappointed by the technology, so don’t take my words for granted.

4.5 【今日阅读】https://github.com/jordanlewis/gcassert gcassert is a program for making assertions about compiler decisions in Go programs, via inline comment directives like //gcassert:inline.

4.4 【今日阅读】https://blog.testdouble.com/posts/2023-04-03-never-staff-to-the-peak/ Regardless of whether additional complexity is essential (valuable) or incidental (waste), all complexity adds to the carrying cost of software. As a result, doing low-priority work costs the business twice: paying people to build things it doesn’t need, sure, but also paying higher maintenance costs on the existing things it really did need. That’s because, as as is often forgotten: as complexity goes up, maintenance costs increase in super-linear proportion!

4.3 【今日阅读】https://github.com/dominikh/gotraceui Gotraceui is a tool for visualizing and analyzing Go execution traces. It is meant to be a faster, more accessible, and more powerful alternative to go tool trace. Unlike go tool trace, Gotraceui doesn’t use deprecated browser APIs (or a browser at all), and its UI is tuned specifically to the unique characteristics of Go traces.

4.2 【今日阅读】https://www.maxcountryman.com/articles/value-modes-and-mud-balls As an industry, we've become accustomed to methodologies that yield iterative value, be it Agile or other similar approaches. This tends to work exceptionally well for problem spaces where accretion is an effective way forward. For example, landing page optimization can be as simple as changing some variables, running tests and observing the results, then rolling out the ones with statistically significant outcomes. However, adding more mud onto an already established ball only leaves you with a larger ball of mud.

4.1 【今日阅读】https://lobste.rs/s/u7y4lk/modules_matter_most_for_masses what matters in the module system for programming in the large 

3.31 【今日阅读】https://lobste.rs/s/icbyfz/type_system_fortnite_s_verse_language We see ourselves at the very beginning of a 2 or 3 year process of rewriting all of the game play logic of Fortnite Battle Royale (which is now C++) in Verse…

3.30 【今日阅读】https://zhuanlan.zhihu.com/p/617818350 ChatGPT 处理小脚本很容易，你直接把脚本都复制粘贴进去，然后告诉 ChatGPT 我要什么就可以了。和拜佛许愿没啥区别。那么如何应用到大型代码仓库上呢？

3.29 【今日阅读】https://lobste.rs/s/xpotym/praise_vite Webpack was written by astronaut architects who were obsessed with making things possible but not with actually solving problems. In practice, it meant that even though no one actually has interesting bundling requirements, everyone ends up writing their own bundling logic for some reason. Parcel and ESBuild also got this right.

3.28 【今日阅读】https://loige.co/the-senior-dev/ The Definition of Senior: A Look at the expectations for Software Engineers

3.27 【今日阅读】https://zhuanlan.zhihu.com/p/616860260 ChatGPT 的 4000 个 token 上下文不够用怎么办？关于这个主题有一篇更详细的学术 survey https://arxiv.org/pdf/2302.07842.pdf

3.26 【今日阅读】https://tweedegolf.nl/en/blog/88/data-oriented-design DoD is commonly used in game programming, where runtime speed defines what is possible. Recently it's seen more use in other domains, for instance in the Zig and Rust compilers, and projects that focus on runtime speed like Mold and Bun.

3.25 【今日阅读】https://tomasp.net/blog/2015/library-frameworks/ To end on a lighter note, you can find frameworks not just in software, but also in ordinary life. If you buy package holidays, you're buying a framework - they transport you to some place, put you in a hotel, feed you and your activities have to fit into the shape provided by the framework (say, go into the pool and swim there). If you travel independently, you are composing libraries. You have to book your flights, find your accommodation and arrange your program (all using different libraries). It is more work, but you are in control - and you can arrange things exactly the way you need.

3.24 【今日阅读】https://boston.conman.org/2023/03/06.1 The reactions to my previous post were interesting—it wasn't a “unit test.” At best, it might have been an “integration test” but because it involved actual work (i.e. interaction with the outside world via nasty nasty side effects, aka I/O) it immediately disqualified it as a “unit test.” And to be honest, I was expecting that type of reaction—it appears to me that most unit test proponents tend to avoid such “entanglements” when writing their “battle tested” code (but I'm also willing to admit that's the cynical side of me talking). There were also comments about how 100% code coverage was “unrealistic.”

Sigh.

3.23 【今日阅读】https://lobste.rs/s/fjb8ch/why_people_misuse_inheritance “laziness” isn’t really a good way to analyze these sorts of things. When programmers are being “lazy” they’re just doing what their tools guide them to doing. We can and should modify these tools so that the “lazy” solution is correct rather than try to fix programmers.

3.22 【今日阅读】https://serce.me/posts/21-03-2023-write-predictable-software-not-ergonomic The issue with how many APIs are designed is that they make it harder to opt-in for predictable behaviour. Let's consider the connection pool example again. Setting max while omitting min rarely makes sense, yet that’s how many APIs work. If you want to make your application predictable, you often have to configure max to the same value as min - something that’s very easy to overlook. A safe API that follows the above patterns forces you to consider the environment in which your software will be running and helps to make an appropriate choice. When the setMaximumPoolSize example from the beginning of the article is rewritten in this paradigm, it switches from an ambiguous statement into a line that clearly signals its intention.

3.21 【今日阅读】https://deno.com/blog/package-json-support The latest release of Deno introduced a significant change: providing enhanced Node and NPM compatibility through package.json support. 革命者投降了

3.20 【今日阅读】https://tigerbeetle.com/blog/a-database-without-dynamic-memory/ Building a system that allocates memory once up-front requires up-front thinking. For many developers (like myself) it is a big adjustment. But as we’ve found: you spend just a few weeks thinking through the memory you need, and it pays off massively over time.

3.19 【今日阅读】https://tratt.net/laurie/blog/2023/rusts_two_kinds_of_assert_make_for_better_code.html Rust's distinction between `assert!` and `debug_assert!` macros is a useful feature that helps programmers write better code. The author explains that `assert!` checks a condition at runtime and panics if it fails, while `debug_assert!` only checks the condition in debug mode and does nothing in release mode. This allows programmers to use `assert!` for conditions that must always hold (such as invariants) and `debug_assert!` for conditions that are only relevant for debugging (such as preconditions and postconditions)

3.18 【今日阅读】https://balintreczey.hu/blog/how-to-speed-up-your-next-build-with-firebuild/ Firebuild intercepts all processes started by the command to cache their outputs. Next time when the command or any of its descendant commands is executed with the same parameters, inputs and environment, the outputs are replayed (the command is shortcut) from the cache instead of running the command again.

3.17 【今日阅读】https://www.bolddata.org/blog/python-tdd-with-chatgpt/ The post explores how to use ChatGPT, a language model that can generate Python code, with test-driven development (TDD), a software development process that relies on writing tests before writing code. The post shows how ChatGPT can pass some simple tests, but also fails at some more complex ones. The post concludes that ChatGPT is not yet ready for production use, but it is a promising tool for prototyping and learning.

3.16 【今日阅读】https://zhuanlan.zhihu.com/p/614341278 基于 GPT-4 / vscode 的重构工具方案，以及本地部署大语言模型方案

3.15 【今日阅读】https://github.com/rustymagnet3000/lldb_debugger Helpful commands when using lldb

3.14 【今日阅读】https://www.youtube.com/watch?v=NAVbI1HIzCE we’re going to take a small piece of code and convert it through several versions, from a full Object Oriented implementation with the data scattered around, to a Data Oriented Design version where the data is well organized

3.13 【今日阅读】https://www.rubick.com/steel-threads/ what Steel Threads are and how they can help engineers design better systems. Steel Threads are a way of building a minimal end-to-end implementation of a feature or functionality, without worrying about the details or quality of each component. The idea is to create a working prototype that can be tested and improved iteratively, rather than spending a lot of time on planning and designing each part separately. Steel Threads can help engineers avoid integration problems, reduce complexity, and deliver value faster.

3.12 【今日阅读】https://www.youtube.com/watch?v=_ahvzDzKdB0

* A language should be designed not by a few experts, but by a community of users who can grow and adapt it to their needs.
* A language should have a small core of powerful features that can be composed and extended to create new features. This way, users can define their own abstractions and libraries without relying on the language designers.
* A language should support multiple paradigms and styles of programming, such as object-oriented, functional, imperative, declarative, etc. This allows users to choose the best tools for each problem domain and express their ideas more clearly and concisely.
* A language should be consistent and coherent in its syntax and semantics. It should avoid arbitrary restrictions and special cases that make it hard to learn and use. It should also avoid unnecessary complexity and redundancy that make it hard to read and maintain.

3.11 【今日阅读】https://lobste.rs/s/uo3sck/what_good_debugger_can_do What a good debugger can do

3.10 【今日阅读】https://www.philipotoole.com/what-i-learned-from-programming-a-database/ 
If there was one piece of advice I would give to fellow developers looking to improve their programming ability, it would be to become part of a database development team.

3.9 【今日阅读】https://github.com/gtramontina/ooze Mutation testing is a technique used to assess the quality and coverage of test suites. It involves introducing controlled changes to the code base, simulating common programming mistakes. These changes are, then, put to test against the test suites. A failing test suite is a good sign. It indicates that the tests are identifying mutations in the code—it "killed the mutant". If all tests pass, we have a surviving mutant. This highlights an area with weak coverage. It is an opportunity for improvement.

3.8 【今日阅读】https://marcellerusu.com/your_client_side_state_is_a_lie.html The link you provided is a blog post by Marcel Rusu, who challenges the common practice of client-side state management in web development. He claims that client-side state is a lie because it is always derived from some source of truth, such as the server or the user input. He argues that client-side state management introduces unnecessary complexity, inconsistency and bugs, and that it should be replaced by a simpler approach based on declarative rendering and server-side state.

3.7 【今日阅读】https://blog.polybdenum.com/2023/03/05/fixing-the-next-10-000-aliasing-bugs.html Invariants are essential to large scale programming, because it is impossible to hold the entire state of a system in your head at once. Invariants allow you to focus only on the parts of the code responsible for upholding that invariant, and to just assume it holds elsewhere, thus reducing the combinatorial explosion of the state space and allowing the development of software larger than trivial toy examples.

3.6 【今日阅读】https://useadrenaline.com/playground a chatbot that helps you debug your code

3.5 【今日阅读】 https://b23.tv/KjbDASN 关于"Signals 是不是 Web 框架未来"的梳理和感想(自言自语)

3.4 【今日阅读】https://opensource.googleblog.com/2023/03/introducing-service-weaver-framework-for-writing-distributed-applications.html More importantly, microservices severely impacted our ability to make cross-binary changes. It made us do things like flag-gate new features in each binary, evolve our data formats carefully, and maintain intimate knowledge of our rollout processes. Finally, having a predetermined number of specific microservices effectively froze our APIs; they became so difficult to change that it was easier to squeeze all of our changes into the existing APIs rather than evolve them.

3.3 【今日阅读】https://www.deeplearning.ai/the-batch/issue-180/ Participants who used Codex generally produced code that was less functional and secure, yet they expressed greater confidence in it.

3.2 【今日阅读】https://concerningquality.com/logical-time-determinism/ Recently, Tomorrow Corporation released this video of their in-house tech stack doing some truly awesome time-travel debugging of a production-quality game. You should watch this video, even if you don’t read this post, because the workflow that they’ve created is really inspiring. The creator kept bringing up the fact that the reason their tools can do this is that they have determinism baked into them at the very foundational levels. You simply can’t bolt this on at higher levels in the stack.

This got me thinking - not only do we rarely have this level of control in our projects, but I think it’s rare to even understand how determinism is possible in modern systems that are interactive, concurrent, and distributed.

3.1 【今日阅读】https://hudi.apache.org/blog/2021/07/21/streaming-data-lake-platform Enter Hudi, an incremental framework that supports the above requirements outlined in our previous section. In short, Hudi (Hadoop Upsert Delete and Incremental) is an analytical, scan-optimized data storage abstraction which enables applying mutations to data in HDFS on the order of few minutes and chaining of incremental processing. https://www.uber.com/en-KR/blog/hoodie/

2.28 【今日阅读】https://book.archguard.org/ 在这本《架构治理模式》，将介绍一系列调整现有人员、流程和技术的实践与模式等，使架构符合架构师预期的设想，以最好地帮助架构师交付业务成果。

2.27 【今日阅读】https://www.youtube.com/watch?v=72y2EC5fkcE 融合了录制回放功能的整套开发工具链是怎样的？

2.26 【今日阅读】http://wrigstad.com/oracle/ludvig_thesis.pdf The information saved in the snapshot is only valuable insofar as references
and pointers will keep their meaning when restored. For many kinds of references and pointers, this is not directly the case. What broad categories do we have, and what solutions exist? The issue is twofold: 1) Are references to each entity valid upon restoring, and 2) If not, can all the references to it be identified and updated?

2.25 【今日阅读】https://www.maxcountryman.com/articles/let-it-fail Yeah. You will destroy yourself if you try to fix everything on overtime. When things stay broken for a while, people suddenly get some appreciation for all the systems that “magically “ just work all the time. Suddenly there’s talk about scheduled maintenance and which resources are assigned to keep things running.

2.24 【今日阅读】https://samsartor.com/guis-1/ Around 4 years ago while working on SketchUp Web (an interesting mix of legacy C++ and shiny VueJS) I got the idea to try making a Vue/MobX-style reactivity system in Rust. I wasn’t so concerned with rendering or layout. All I wanted was a way to mutate random stuff in closures, and then have everything else update automatically. That turned out to be hard.

2.23 【今日阅读】https://capitalex.codeberg.page/give-me-flexibility-and-give-me-types/ Give Me Flexibility *and* Give Me Types.

2.22 【今日阅读】https://m.youtube.com/watch?v=XjwJeHRa53A Why You Don't Trust Your Linter

2.21 【今日阅读】https://zhuanlan.zhihu.com/p/607798970 所以我相信，AI不仅仅会干掉大量的低端岗位。同时因为AI辅助，使得大量初级程序员可以代替高级程序员，从而极大削弱这些年迈程序员原本就不多的议价空间。我们除了拥抱变化，别无选择。

2.20 【今日阅读】https://blog.trailofbits.com/2019/11/11/test-case-reduction/ Imagine reducing the amount of code and time needed to test software, while at the same time increasing the efficacy of your tests and making your debugging tasks easier—all with minimal human effort. It seems too good to be true, but we’re going to explain how test-case reduction can do all this (and maybe more).

2.19 【今日阅读】https://mp.weixin.qq.com/s/Jxw34Kt66xDyxbtpEv_V_g piglei 对 14 年工作经验的总结

2.18 【今日阅读】https://www.functionize.com/blog/the-top-10-test-cases-that-benefit-from-ai-power Modern web applications need a different approach to testing. Here, we see how AI-powered solutions increase the number and type of tests you can automate. The top 10 test cases that benefit from AI power

2.17 【今日阅读】https://martinfowler.com/articles/retrospective-antipatterns.html Retrospectives Antipatterns

2.16 【今日阅读】https://www.warp.dev/blog/why-is-building-a-ui-in-rust-so-hard Rust 对指针的限制太严格了，所以我们用 EntityId 来代替指针，称之为 Entity-Component-System

2.15 【今日阅读】https://useadrenaline.com/ 

* Client-side intelligence (e.g. static code analysis) could be used to build a better prompt for GPT-3.
* Instead of simply explaining your error, Adrenaline should provide chain-of-thought reasoning for how it fixed the error.
* In addition to chain-of-thought reasoning, Adrenaline could provide a ChatGPT-style assistant to answer questions about your error. I can even see Adrenaline being repurposed as a "coding tutor" for beginners.
* Creating a VSCode extension that does this would eliminate the friction of copy-pasting your code and error message into the site.

2.14 【今日阅读】http://www.righto.com/2023/02/silicon-reverse-engineering-intel-8086.html You might expect flags to be a simple part of a CPU, but the 8086's flags are surprisingly complex. About 1/3 of the ALU is devoted to flag computation and storage. Each flag is implemented with completely different circuitry. The 8086 is a CISC processor (Complex Instruction Set Computer), where the instruction set is designed to be powerful and to minimize the gap between machine language and high-level languages.15 This can be seen in the implementation of the flags, which are full of special cases to increase their utility with different instructions.

2.13 【今日阅读】https://en.m.wikipedia.org/wiki/Heisenbug In computer programming jargon, a heisenbug is a software bug that seems to disappear or alter its behavior when one attempts to study it.

2.12 【今日阅读】https://www.rapitasystems.com/blog/what-really-happened-software-mars-pathfinder-spacecraft The Mars Pathfinder spacecraft experienced a series of total system resets due to a priority inversion caused by a long-running communications task. Engineers were able to diagnose and fix the problem by turning on a boolean parameter that indicates whether priority inheritance should be performed by the mutex. This was made possible by the presence of a C language interpreter in the system, which allowed them to upload a short C program to the spacecraft. The solution to the problem was first identified in a paper by L. Sha, R. Rajkumar, and J. P. Lehoczky in 1990, and all three authors were present at the keynote address where the story was told. This story highlights the importance of detailed traces of system behavior for diagnosing problems, as well as the value of having debugging facilities in the system.

2.11 【今日阅读】https://paperless.blog/we-need-programming-mentors Mentoring is an essential part of advancing the art of programming, as it allows experienced developers to pass on their hard-earned knowledge to the next generation. Without this, each generation would have to go through the same mistakes and take longer to advance the state of the art. Examples of mistakes include using text editors without knowledge of the code base, not knowing the weaknesses of different technologies, not knowing the real side effects of having a good test suite, not knowing when to refactor, and not knowing how to name things. Mentoring is the best way to impart this knowledge, as it allows for relevant suggestions to be given in the moment and for in-depth explanations when a quick hint is not enough.

2.10 【今日阅读】https://pernos.co/examples/use-after-free Debugging a use-after-free in gdb with Pernosco involves capturing a recording of the bug, examining the instructions executed, and tracing the dataflow of the pointer in question. In this case, the pointer was stored in gdb_stdout and later destroyed by a std::unique_ptr, leaving gdb_stdout as a dangling pointer. After examining the code, it was found that logfile was stored as a raw pointer in gdb_stdout without taking ownership of it, leading to the use-after-free bug. It is interesting to note that Pernosco was able to quickly identify the source of the bug and provide a detailed explanation of the bug's cause.

2.9 【今日阅读】https://github.com/golang/go/issues/57175 As the Go user base grows, more and more Go developers are seeking to understand the performance of their programs and reduce resource costs. However, they are locked into the relatively limited diagnostic tools we provide today. Some teams build their own tools, but right now that requires a large investment. This issue extends to the Go team as well, where we often put significant effort into ad-hoc performance tooling to analyze the performance of Go itself.

2.8 【今日阅读】https://www.adaptivecapacitylabs.com/blog/2018/03/23/moving-past-shallow-incident-data/ This is why we started Adaptive Capacity Labs: to demonstrate that meaningful insight comes from studying how real people do real work under real conditions. Does your company rely on shallow data like above? What investments in deeper analytical methods have they made? Take a look at what we do to assess your company’s capacity to learn in these ways.

2.7 【今日阅读】https://www.endpointdev.com/blog/2023/02/migration-tips-and-tricks/ Data Migration Tips

2.6 【今日阅读】https://www.worldofbs.com/minimize-state/ All Programming Philosophies Are About State

1.19 【今日阅读】https://uptrace.dev/blog/posts/go-memory-arena.html Go 1.20 release added new experimental arena package that provides memory arenas. This article explains what memory arenas are and how you can use them to reduce garbage collection overhead and make your programs faster.

1.18 【今日阅读】https://www.metalevel.at/prolog/debugging The methods are based on declarative ways of reading Prolog programs, exploiting logical properties to quickly narrow down mistakes. We call this approach declarative debugging.

1.17 【今日阅读】https://verdagon.dev/blog/when-to-use-memory-safe-part-2 How Memory Safety Approaches Speed Up and Slow Down Development Velocity

1.16 【今日阅读】https://chriswarrick.com/blog/2023/01/15/how-to-improve-python-packaging/ There is an area of Python that many developers have problems with. This is an area that has seen many different solutions pop up over the years, with many different opinions, wars, and attempts to solve it. Many have complained about the packaging ecosystem and tools making their lives harder. Many beginners are confused about virtual environments. But does it have to be this way? Are the current solutions to packaging problems any good? And is the organization behind most of the packaging tools and standards part of the problem itself?

1.15 【今日阅读】https://hoho.com/posts/your-stack-is-not-the-product/ Ship the product. Frequently and reliably. Support growth. Be able to bring in more people, gradually, that can do (1).

1.14 【今日阅读】https://dusted.codes/the-type-system-is-a-programmers-best-friend Good types can prevent bugs, Rich types protect you from future mistakes, Smart types can prevent unwanted side effects

1.13 【今日阅读】https://blog.janestreet.com/the-joy-of-expect-tests/ I hope this post encourages more people to try the “snapshot” style of testing. My own experience with it is that I never want to go back to a workflow where my computer isn’t finishing my tests for me.

1.12 【今日阅读】https://futureofcoding.org/episodes/061 Programming as Theory Building by Peter Naur

1.11 【今日阅读】https://lucasfcosta.com/2022/09/15/deadlines.html Short-term profits are not a reliable indicator of the performance of management. Anybody can pay dividends by deferring maintenance, cutting out research, or acquiring another company. — Deming, W. Edwards. Out of the Crisis, reissue (p. 19). MIT Press. Kindle Edition.

1.10 【今日阅读】https://buttondown.email/hillelwayne/archive/in-defense-of-testing-mocks/ In Defense of Testing Mocks

1.9 【今日阅读】https://henrikwarne.com/2023/01/07/there-is-no-software-maintenance/ let’s stop talking about software maintenance is if it were a separate activity. It is not. It is just software development.

1.8 【今日阅读】https://mike.zwobble.org/2023/01/reflections-on-testing-without-mocks/ Question #1: which parts of the system do you replace with test doubles? Question #2: how do we make the test doubles?  Question #3: who's responsible for making the test doubles?

1.7 【今日阅读】https://quick-lint-js.com/blog/cpp-vs-rust-build-times/ Are compilation times a problem with Rust? Yes.  Are build times as bad with Rust as with C++? Yes.

1.6 【今日阅读】https://buttondown.email/hillelwayne/archive/why-modeling-finds-bugs-without-model-checking/ In other words, writing lets us keep track of more things. In the case of large systems, “more things” means more interactions between complex components. This is why even writing down specifications in English helps a lot. Formal specification languages just push that further by encoding intricate components more densely, which helps us chunk them up.

1.5 【今日阅读】https://lobste.rs/s/cwkbyg/first_public_release_pushup_new_compiler Pushup is a mix of a new syntax consisting of Pushup directives and keywords, Go code, and HTML markup.

1.4 【今日阅读】https://blogs.newardassociates.com/blog/2023/you-want-modules-not-microservices.html You Want Modules, Not Microservices. Dissecting why everybody keeps talking about microservices.

1.3 【今日阅读】https://mp.weixin.qq.com/s/3k-dtYHmyjFlX2BcnrtaQQ 今年是《敏捷宣言》签署的第20个年头。与Scrum认证和“敏捷教练”头衔满天飞的热闹情形相对，国内的敏捷社区倒是流行起了一种略显悲观的“失败论”。不论将“失败”归因于敏捷理论、敏捷的布道者、还是敏捷的实践者，很显然，越来越多的人开始意识到，尽管“敏捷”这个漂亮的词受到了IT行业的广泛青睐，但行业的总体能力——正如笔者在《敏捷中国史话》中所发现的——提升非常有限。大部分企业、团队和个人仍在低能力水平上挣扎，与现代商业环境所期望的数字化能力之间的差距不但没有缩小、反而有不断扩大的趋势。

1.2 【今日阅读】https://saaramar.github.io/memory_safety_blogpost_2022/ Survey of security mitigations and architectures: Hardware solutions, Software mitigations, Safe programming languages

1.1 【今日阅读】https://spindas.dreamwidth.org/4207.html Who needs a backend? ChatGPT as the universal Redux reducer

12.31 【今日阅读】https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang Here's a list of lies we tell ourselves to keep using Golang:

* Others use it, so it must be good for us too
* Everyone who has concerns about it is an elitist jerk
* Its attractive async runtime and GC make up for everything else
* Every language design flaw is ok in isolation, and ok in aggregate too
* We can overcome these by "just being careful" or adding more linters/eyeballs
* Because it's easy to write, it's easy to develop production software with
* Because the language is simple, everything else is, too
* We can do just a little of it, or just at first, or we can move away from it easily
* We can always rewrite it later

12.30 【今日阅读】https://paroj.github.io/gltut/Further%20Study.html#idp13031 Debugging OpenGL code is very difficult. Frequently when there is a bug in graphics code, the result is a massively unhelpful blank screen. If the problem is localized to a single shader or state used to render an object, the result is a black object or general garbage. Compounding this problem is the fact that OpenGL has a lot of global state. One of the reasons this book will often bind objects, do something with them, and then unbind them, is to reduce the amount of state dependencies. It ensures that every object is rendered with a specific program, a set of textures, a certain VAO, etc. It may be slightly slower to do this, but for a simple application, getting it working is more important.

12.29 【今日阅读】https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/agarwal Succinct is a data store that enables efficient queries directly on a compressed representation of the input data. Succinct uses a compression technique that allows random access into the input, thus enabling efficient storage and retrieval of data. In addition, Succinct natively supports a wide range of queries including count and search of arbitrary strings, range and wildcard queries. What differentiates Succinct from previous techniques is that Succinct supports these queries without storing indexes — all the required information is embedded within the compressed representation.

12.28 【今日阅读】https://www.youtube.com/watch?v=dH7QUdXeVrI Using CHERI's mechanisms, software can efficiently implement fine-grained, reliable, spatial, and temporal memory protection and scalable compartmentalization without needing to resort to MMU-based isolation. Though common wisdom holds that hardware capability systems are impractical, CHERI achieves its goals with low overheads while retaining compatibility with C, including modern features such as dynamic linking and thread-local storage.

12.27 【今日阅读】https://www.youtube.com/watch?v=7hdJQkn8rtA Critical Program Reading (1975) - 16mm Film

12.26 【今日阅读】https://www.jamesshore.com/v2/projects/testing-without-mocks/testing-without-mocks Testing Without Mocks: A Pattern Language. Foundational Patterns; Architectural Patterns; Logic Patterns; Infrastructure Patterns; Nullability Patterns; Legacy Code Patterns

12.25 【今日阅读】https://cacm.acm.org/magazines/2023/1/267976-the-end-of-programming/fulltext Programming will be obsolete. I believe the conventional idea of "writing a program" is headed for extinction, and indeed, for all but very specialized applications, most software, as we know it, will be replaced by AI systems that are trained rather than programmed.

12.24 【今日阅读】https://minimalmodeling.com/ Minimal Modeling approach: We use a simple logical modeling approach inspired by Anchor Modeling. We document the database by dissecting it into anchors, attributes and links, and also derived data and some textual narratives.

12.23 【今日阅读】https://devos50.github.io/blog/2022/ipod-touch-qemu/ Emulating an iPod Touch 1G and iPhoneOS 1.0 using QEMU (Part I)

12.22 【今日阅读】https://mdalmijn.com/p/11-laws-of-software-estimation-for-complex-work 11 Laws of Software Estimation for Complex Work

12.21 【今日阅读】https://www.b-list.org/weblog/2022/dec/19/boring-python-code-quality/ I don’t mean “reliable” or “bug-free” or “no incidents”. While there is some overlap, and some of the things I’ll be recommending can help to reduce bugs, I also want to be clear: there will be bugs. There will be incidents where a feature or maybe an entire service is down. “Boring”, to me, is about the sources of those incidents.

12.20 【今日阅读】https://mp.weixin.qq.com/s/WrPAL9qQbXFihLfVnepY3g 本文作者从微信团队维护的带货类项目所遇卡点出发，尝试用领域驱动设计方法（简称DDD），保障在快节奏、多人协作的项目迭代中，维持系统的可维护性、可拓展性、高内聚低耦合和稳定性。作者首先剖解相关概念原理，之后代入亲身参与的微信团队实际项目、围绕DDD方法进行优化实操。

12.19 【今日阅读】https://inspirezone.tech/9-indispensable-rules-for-debugging-software-and-hardware/ 9 Indispensable Rules for Debugging Software and Hardware (Book review)

12.18 【今日阅读】https://codersatwork.com/ Based on nearly eighty hours of conversations with fifteen all-time great programmers and computer scientists, the Q&A interviews in Coders at Work provide a multifaceted view into how great programmers learn to program, how they practice their craft, and what they think about the future of programming.

12.17 【今日阅读】https://antonio-cooler.gitbook.io/coolervoid-tavern/detecting-heap-memory-pitfalls Rules to detect Heap security pitfalls

12.16 【今日阅读】https://austinhenley.com/blog/morechallengingprojects.html One year ago, I posted Challenging projects every programmer should try. It included a text editor, Space Invaders, a BASIC compiler, a small operating system, a spreadsheet, and a video game console emulator. It blew up across the internet, amassing over 100,000 views in a month (read more about it going viral). I'm now expanding the list with more "modern" projects: Ray tracer, Key-value store web API, Web browser, Stock trading bot

12.15 【今日阅读】https://xi-editor.io/docs/crdt.html CRDT - An approach to async plugins and undo

12.14 【今日阅读】https://www.youtube.com/playlist?list=PL6CJYn40gN6hLwcJ2cgLNtsbr6zUMZSEJ This series will give you an overview of debugging and profiling techniques for C/C++ (and Qt) applications, as well as graphics optimizations tools for OpenGL.

12.13 【今日阅读】https://concerningquality.com/models/ I’ve become a bit model-obsessed as of late. By “model,” I mean a simplified representation of a program. No databases. No HTTP. Just pure logic. What interests me so much about models is that they exemplify software minimalism. We often talk about essential vs. accidental complexity - well, models are the embodiment of the essential. We have an ongoing battle against complexity at the language level, with tons of new languages providing support for immutability, reference sharing control, and other features of modern semantics. But I can’t help but still ask: is it really enough? Is software really getting any simpler?

12.12 【今日阅读】https://github.com/facebookresearch/metaseq/blob/main/projects/OPT/chronicles/README.md logbook from training the GPT-3 sized OPT model

12.11 【今日阅读】https://news.ycombinator.com/item?id=33934580 The biggest problem facing the front-end space today isn't so much of complexity of a particular library, rendering technique, or view/model architecture, but rather lots of bad ideas glued together, creating nightmare scenarios for companies trying to maintain products.
A micro dependency system with never ending breaking changes to glue different tools and libraries together - bad idea.

Using un-opinionated "libraries" that don't scale well, but at scale - bad idea.

Technology organizations trying to stay relevant by simply adopting every next hyped fad out there, rather than stepping back to get a bigger picture of what the front-end space actually needs - bad idea.

The list goes on, for quite a long time.

And all of these issues are further exacerbated by an army of junior developers entering the front-end development space, along with recruiters subscribing to buzzwords to hire them.

12.10 【今日阅读】https://jvns.ca/blog/2022/12/08/a-debugging-manifesto/ A debugging manifesto

12.9 【今日阅读】https://asahilinux.org/2022/12/gpu-drivers-now-in-asahi-linux/ Of course, we couldn’t build an OpenGL driver in under two years just ourselves. Thanks to the power of free and open source software, we stand on the shoulders of FOSS giants. The compiler implements a “NIR” backend, where NIR is a powerful intermediate representation, including GLSL to NIR translation. The kernel driver users the “Direct Rendering Manager” (DRM) subsystem of the Linux kernel to minimize boilerplate. Finally, the OpenGL driver implements the “Gallium3D” API inside of Mesa, the home for open source OpenGL and Vulkan drivers. Through Mesa and Gallium3D, we benefit from thirty years of OpenGL driver development, with common code translating OpenGL into the much simpler Gallium3D. Thanks to the incredible engineering of NIR, Mesa, and Gallium3D, our ragtag team of reverse-engineers can focus on what’s left: the Apple hardware.

12.8 【今日阅读】https://vickiboykis.com/2022/12/05/the-cloudy-layers-of-modern-day-programming/ Recently, I’ve come to the realization that much of what we do in modern software development is not true software engineering. We spend the majority of our days trying to configure OpenSprocket 2.3.1 to work with NeoGidgetPro5, both of which were developed by two different third-party vendors and available as only as proprietary services in FoogleServiceCloud.

The name of this activity is, brilliantly summarized as VendorOps, from this blog post

12.7 【今日阅读】https://github.com/google/go-flow-levee An input program's data flow is explored using a combination of pointer analysis, static single assignment analysis, and taint analysis. "Sources" must not reach "sinks" without first passing through a "sanitizer." Additionally, source data can "taint" neighboring variables during a "propagation" function call, such as writing a source to a string. Such tainted variables also must not reach any sink.

12.6 【今日阅读】https://driftingin.space/posts/you-might-not-need-a-crdt Although CRDTs aren’t always the best solution for always-online collaborative apps, it’s still fascinating tech that has real use cases. Apps that need to run offline in general are good candidates for CRDTs.

12.5 【今日阅读】https://stayrelevant.globant.com/en/technology/agile-delivery/active-knowledge-in-software-development/ Our knowledge of the old work fades away when we move on to other work. Sometimes we have crystal clear memory, but essential details fade from our memory when we aren’t reminded of them in a work context. This fading happens at the individual level but also at the level of teams and organizations. If a person leaves a team, the part of the team’s active knowledge that person had is effectively gone if it wasn’t generated through shared work.

12.4 【今日阅读】https://lobste.rs/s/tuz3tu/twenty_five_thousand_dollars_funny_money I don’t think that creating distinct types for “dollars” and “pennies” is a very good idea, although I realize this is the fix that the article proposes.

12.3 【今日阅读】https://github.com/CMU-program-analysis/CMU-program-analysis.github.io/blob/master/2022/lecture-slides/01-introduction.pdf Program analysis slides

12.2 【今日阅读】https://www.jetpack.io/blog/do-repeat-yourself-global-packages-considered-harmful/ We took the convenience of virtual environments, the UX of npm, and the immutability of NixOS to create this magical local-like experience with Devbox.

12.1 【今日阅读】https://jakelazaroff.com/words/tailwind-is-a-leaky-abstraction/ Tailwind is commonly described as “utility classes”, but that's a bit of an understatement. It's essentially a small language you write in the class attributes of your HTML that compiles to a combination of CSS rules and selectors — an abstraction over CSS. But all abstractions leak, and Tailwind is very leaky.

11.30 【今日阅读】https://r2c.dev/blog/2022/static-analysis-speed/ Program analysis is an extremely interesting discipline that aims to combine an impossible task (finding undesirable parts of programs) with practical usage (being useful to developers to fix their code). Practical usage takes many forms ranging from convenience of information and quality of findings to the speed at which the analysis is carried out.

11.29 【今日阅读】https://zhuanlan.zhihu.com/p/585251693 尝试总结一些持续维护项目变得难以维护的原因，以及如何设计才能保持良好的可维护性。

11.28 【今日阅读】https://osquery.io/ Osquery uses basic SQL commands to leverage a relational data-model to describe a device.

11.27 【今日阅读】https://surfingcomplexity.blog/2022/11/24/writing-docs-well-why-should-a-software-engineer-care/ Writing docs well: why should a software engineer care?

11.26 【今日阅读】https://blog.andrewbrey.com/2022-10-12-your-monorepo-dependencies-are-asking-for-trouble/ Your Monorepo Dependencies Are Asking for Trouble

11.25 【今日阅读】https://www.yet-another-blog.com/porting_the_game_to_jai_part0/ my plan to porting is the following:
Copy a small piece of code from D or C++ to jai and make it compile.
Call the new jai code instead of the old D or C++ code.
Replay a recorded game session.
If the replay diverged, porting introduced a bug. Fix the bug.
If the replay didn’t diverge, porting was successful. repeat.

11.24 【今日阅读】https://diataxis.fr/ The Diátaxis framework aims to solve the problem of structure in technical documentation. It adopts a systematic approach to understanding the needs of documentation users in their cycle of interaction with a product. Diátaxis identifies four modes of documentation - tutorials, how-to guides, technical reference and explanation. It derives its structure from the relationship between them.

11.23 【今日阅读】https://matthewtejo.substack.com/p/why-twitter-didnt-go-down-from-a Twitter supposedly lost around 80% of its work force. What ever the real number is, there are whole teams with out engineers on it now. Yet, the website goes on and the tweets keep coming. This left a lot wondering what exactly was going on with all those engineers and made it seem like it was all just bloat.

11.22 【今日阅读】https://www.baldurbjarnason.com/2022/wtf-is-a-framework/ WTF do you mean when you say ‘framework’?

11.21 【今日阅读】https://maskray.me/blog/2021-12-19-why-isnt-ld.lld-faster LLD is the LLVM linker. Its ELF port is typically installed as ld.lld. This article makes an in-depth analysis of ld.lld's performance. The topic has been in my mind for a while. Recently Rui Ueyama released mold 1.0 and people wonder why with multi-threading its ELF port is faster than ld.lld. So I finally completed the article.

11.20 【今日阅读】https://edoput.it/2022/11/18/hypothesis.html Normal “automated” software testing is surprisingly manual. Every scenario the computer runs, someone had to write by hand. Hypothesis can fix this.

11.19 【今日阅读】https://devenv.sh/ Build, share, and run your local development environments with a single command. Without containers.

11.18 【今日阅读】https://sapling-scm.com Sapling provides convenient methods for stacking, iterating on, and submitting your work for code review. It removes the hassle of branches and the dreaded "detached HEAD" state.

11.17 【今日阅读】https://verdagon.dev/blog/zero-cost-memory-safety-regions-overview A region is a grouping of data that we can freeze and unfreeze as one, to make it either "mutable" or "immutable".

11.16 【今日阅读】https://queue.acm.org/detail.cfm?id=3570920 Two teams of five is not the same as one team of ten.

11.15 【今日阅读】https://buttondown.email/hillelwayne/archive/why-do-we-call-it-boilerplate-code/ Why do we call it "boilerplate code?"

11.14 【今日阅读】https://deathbykeystroke.com/articles/20220517-business-processes-as-types-lets-explore.html We need a different way of thinking about our problems, it's very familiar but a weird concept in programming to think: "we'll try to do something, see if there's an error, try to do something else, see if there's an error" and so on. Let's start thinking about problems in a way that is "let's perform some setup, try to perform our process, and then handle any errors that happened at any point during the operation".

11.12 【今日阅读】https://www.jetpack.io/ Jetpack builds tools that make cloud development a delightful experience. Whether it’s setting up development environments, or deploying to Kubernetes, we’ve got you covered.

11.11 【今日阅读】https://liuliu.me/eyes/stretch-iphone-to-its-limit-a-2gib-model-that-can-draw-everything-in-your-pocket/ The original Stable Diffusion open-source version cannot run on a 8GiB card.  The main challenge is to run the app on the 6GiB RAM iPhone devices. 6GiB sounds a lot, but iOS will start to kill your app if you use more than 2.8GiB on a 6GiB device, and more than 2GiB on a 4GiB device.

11.10 【今日阅读】https://model-checking.github.io/kani-verifier-blog/2022/10/27/using-kani-with-the-bolero-property-testing-framework.html One question that might arise is: is there any point in using fuzzing alongside Kani? In other words, if we can prove a harness for all inputs with Kani, would we still want to use fuzzing? The answer is yes, because fuzzing and Kani provide complementary benefits.

11.9 【今日阅读】https://news.ycombinator.com/item?id=33519414 The pursuit of realism hit diminishing returns years ago; the manpower needed to make a game hyper-realistic isn't justified by the number of additional sales it will produce. Instead of becoming more realistic, most games have instead focused on having more bright neon particles swirling around on screen. That's much cheaper and much more effective than chasing further realism.
This will likely change in the near future as the industry invents ways to replace human modelers, texture artists, etc, with automated "AI" tools.

11.8 【今日阅读】https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/ golang goroutine + javascript promise

11.7 【今日阅读】https://pragprog.com/titles/atcrime/your-code-as-a-crime-scene/ Your Code as a Crime Scene Use Forensic Techniques to Arrest Defects, Bottlenecks, and Bad Design in Your Programs

11.6 【今日阅读】https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/ golang goroutine + javascript promise

11.5 【今日阅读】https://determinate.systems/posts/nix-direnv Effortless dev environments with Nix and direnv

11.4 【今日阅读】https://lobste.rs/s/ookgy7/how_do_you_sync_code_between_personal I have a desktop and a laptop and I’d like to keep some code in sync between the two. How do you handle this?

11.3 【今日阅读】https://spectrum.ieee.org/functional-programming YOU’D EXPECT the longest and most costly phase in the lifecycle of a software product to be the initial development of the system, when all those great features are first imagined and then created. In fact, the hardest part comes later, during the maintenance phase. That’s when programmers pay the price for the shortcuts they took during development.

11.2 【今日阅读】https://www.copetti.org/writings/consoles/  While conventional PCs tend to evolve ‘incrementally’, new generations of consoles introduce completely new ways of working. What you see here is a series of articles that will hopefully uncover the rationale behind the latest trends in technology.

11.1 【今日阅读】https://github.com/ema/pets The idea behind Pets is that Configuration Management of individual hosts shouldn’t be harder than administering the system by hand. Other configuration management tools typically focus on usage scenarios involving complex relationships between multiple, fairly homogeneous systems. Pets instead focuses on the individual, local machine.

10.31 【今日阅读】https://github.com/benwr/soanm When you install a new operating system on some machine, whether it's a server, a laptop, a desktop, or a VM, it can be a hassle to get to the point of feeling comfortable on that machine. https://github.com/benwr/soanm/tree/main/test_conf

10.30 【今日阅读】https://lobste.rs/s/1640ea/early_speed_optimizations_aren_t Another way to put it: Using the right Big O is never a premature optimization.

10.29 【今日阅读】https://www.shadertoy.com/view/MddGzf 完全跑在 GPU 里的游戏，用 webgl shader 编写

10.28 【今日阅读】https://security.apple.com/blog/towards-the-next-generation-of-xnu-memory-safety/ Without any specialized hardware assistance like Arm Memory Tagging Extension (MTE), practical state-of-the-art mitigations for temporal safety issues revolve around type isolation or sequestering. The core principle of type isolation is that after any particular address has been used for a given “type” of object, only objects of that type can ever exist at that address for the lifetime of the program.

10.27 【今日阅读】https://jrsinclair.com/articles/2022/what-if-the-team-hates-my-functional-code/ We’ve now written this code five different ways. But notice what we haven’t done. We haven’t introduced any side effects. We’re still working with pure functions that each do one small thing. We haven’t added any shared mutable state. And because we haven’t done these things, we can still be confident about our code. It’s still easy to test. It’s still ‘functional.’

10.26 【今日阅读】https://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md#reverse-debugging Also known as Time travel debugging. Provided you use a debugging backend that supports these commands, CodeLLDB be used to control reverse execution and stepping. As of this writing, the only backend known to work is Mozilla's rr. The minimum supported version is 5.3.0.

10.25 【今日阅读】https://blog.ploeh.dk/2022/10/24/encapsulation-in-functional-programming/ Functional programmers may not use the term encapsulation much, but that doesn't mean that they don't share that kind of concern. They often throw around the phrase make illegal states unrepresentable or talk about smart constructors or partial versus total functions. It's clear that they care about data modelling that prevents mistakes.

10.24 【今日阅读】https://ahgamut.github.io/2022/10/23/debugging-c-with-cosmo/ Cosmopolitan Libc provides a suite of debugging features that enhance the C development experience: function call tracing, gdb integration, an ASAN/UBSAN runtime, and more

10.23 【今日阅读】https://www.youtube.com/watch?v=hXnS_Xjwk2Y Writing test cases is laborious, often a little neglected, and ultimately rather unsatisfying, since errors slip through even the most comprehensive test suites. Can we generate tests instead? In this talk I’ll show test case generation using QuickCheck, drawing on experience of applying it at scale at Quviq. I’ll try to explain why property-based testing can be so effective, and how to use it most effectively.

10.22 【今日阅读】https://matduggan.com/why-are-containers-insecure-by-default/ It always starts the same way. A demo is shown where a previously complex problem set is reduced down to running one Magic Tool. It is often endorsed by one of the Big Tech Companies or maintained by them. Some members of the organization start calling for the immediate adoption of this technology.  Overnight this new tool becomes a shorthand for "solution to all of our problems".

10.21 【今日阅读】https://wix-ux.com/when-life-gives-you-lemons-write-better-error-messages-46c5223e1a2f Error messages are part of our daily lives online. Every time a server is down or we don’t have internet, or we forget to add some info in a form, we get an error message. “Something went wrong” is the classic. But what went wrong? What happened? And, most importantly, how can I fix it?

10.20 【今日阅读】https://github.com/wolfpld/tracy https://tracy.nereid.pl/ Frame Trace & Memory Allocation visualizer

10.19 【今日阅读】https://download.swift.org/docs/assets/generics.pdf This is a book about the implementation of generic programming in Swift. While it is primarily meant to be a reference for Swift compiler contributors, it should also be of interest to other language designers, type system researchers, and even just curious Swift programmers

10.18 【今日阅读】https://www.youtube.com/watch?v=US8QG9I1XW0&ab_channel=NDCConferences Functional architecture - The pits of success

10.17 【今日阅读】http://www.huzheng.org/bookstore/TheTaoOfProgramming.pdf 一个好的农民不会不管他的庄稼。一个好的老师不会不管哪怕是最差的学生。一个好的父亲不会让他的任何一个孩子挨饿。一个好的程序员不应拒绝维护他的程序。

10.16 【今日阅读】https://lobste.rs/s/jcx49z/database_without_dynamic_memory static allocation is a forcing function. It helps us as programmers to think through all aspects of resource usage upfront, for all these reasons. Anecdotally, we also find that these constraints lead to better, simpler designs. You get a much crisper mental model of the system at play.

10.15 【今日阅读】https://www.pm.inf.ethz.ch/research/prusti.html Formal verification of system software is notoriously difficult and requires complex specifications and logics (such as separation logic) to reason about pointers, aliasing, and side effects on mutable state.

10.14 【今日阅读】https://medium.com/building-carta/type-annotation-via-automated-refactoring-fd8edfe123d4 We found that out of its 120,000 Python functions, only 14% were fully typed. The scale of the problem was massive. If we could add 30 annotations a day, it would take over 10 years to add them all.

10.13 【今日阅读】https://lobste.rs/s/jktewn/zig_style_generics_are_not_well_suited_for I usually skip posts tagged PLT because they tend to be all about bikeshedding why choosing a particular order for type signatures is not sufficiently ellegant as it doesn’t match the order of isomorphic arguments of linear lambda types or whatever, but something drew me to this one. The fluffy title actually hides a pretty solid article that’s really about the impact of various choices over compiler and tooling efficiency, rather than whether Zig-style generics matches the author’s opinion about how generics ought to be implemented and what behaviour should be the default one. Many of the points that the author makes are anchored in practical experience with large codebases (and tooling for working with large code bases) in other languages, rather than a toy hash table implementation.

10.12 【今日阅读】https://verdagon.dev/blog/when-to-use-memory-safe-part-1 Safety in Non-Memory-Safe Languages

10.11 【今日阅读】https://adamj.eu/tech/2022/06/17/mike-actons-expectations-of-professional-software-engineers/ Mike Acton’s Expectations of Professional Software Engineers

10.10 【今日阅读】https://zhuanlan.zhihu.com/p/571920491 从信息量的角度看监控调试类工具

10.9 【今日阅读】https://www.informit.com/articles/article.aspx?p=31575&seqNum=4 This section presents a historical perspective on JMX, covering the precursor specifications and products, Sun's JMAPI and JDMK, the JMX JSR and current specifications, compliance levels, and a review of some of the current implementations.

10.8 【今日阅读】https://matklad.github.io/2022/10/06/hard-mode-rust.html because allocating resources becomes easy, RAII encourages a sloppy attitude to resources, where they are allocated and destroyed all over the place

9.30 【今日阅读】https://swlaschin.gitbooks.io/fsharpforfunandprofit/content/series/designing-with-types.html Designing with types

9.29 【今日阅读】https://zhuanlan.zhihu.com/p/568859928 调试有状态系统所需要的工具

9.28 【今日阅读】https://www.researchgate.net/publication/318020000_Searching_for_behavioural_bugs_with_stateful_test_oracles_in_web_crawlers Testing modern web applications, so called "Web 2.0" applications has become more difficult due to their "stateful" nature, so the development of an approach capable of testing these applications in order to detect these bugs has become a necessity. The paper presents an automated approach for testing these dynamic web applications, where a combination of dynamic crawling and back-end testing is used to automatically detect behavioural bugs.

9.27 【今日阅读】https://maskray.me/blog/2022-09-25-layering-check-with-clang 用 bazel 解锁 clang 的 module 支持：Bazel generates .cppmap module files from deps attributes. hdrs and textual_hdrs files are converted to textual header declarations while srcs headers are converted to private textual header declarations. deps attributes are converted to use declarations.

9.26 【今日阅读】https://mdalmijn.com/11-laws-of-software-estimation-for-complex-work/ Ask yourself the following question: does it matter if you’re able to predict exactly when something is finished? If you’re confident you’re making the best progress you can towards delivering something valuable, does it make a difference if it’s slower than you expected if that expectation was always flawed and imprecise to begin with?

9.25 【今日阅读】https://boyter.org/posts/expert-excuses-for-not-writing-unit-tests/  Expert Excuses for Not Writing Unit Tests

9.24 【今日阅读】https://zhuanlan.zhihu.com/p/567630362 获取 C++ WebAssembly 的 stacktrace

9.23 【今日阅读】https://mp.weixin.qq.com/s/Xur4s28bmqGsxV7f4d2GZQ Remesh 介绍：用以开发大型复杂 Web App 的 DDD 框架

9.22 【今日阅读】https://media.handmade-seattle.com/practical-data-oriented-design/ Andrew Kelley, creator of Zig, picks up where Mike Acton left off to teach us practical ways to apply data-oriented design.

9.21 【今日阅读】https://mitchellh.com/zig/build-internals zig build written in zig https://nektro.github.io/zigmod/principles.html zigmod.yml is a static Yaml file that does not contain any Zig code. Placing packages’ definition in its own file (say as opposed to in build.zig) was an intentional decision from the start to not allow packages to run arbitrary code on the developer’s machine.

9.20 【今日阅读】https://github.com/struct/isoalloc Its security strategy is originally inspired by Chrome's PartitionAlloc. A memory allocation isolation security strategy is best summed up as maintaining spatial separation, or isolation between objects of different sizes or types. While IsoAlloc wraps malloc and enforces naive isolation by default very strict isolation of allocations can be achieved using the APIs directly.

9.19 【今日阅读】https://docs.wasmtime.dev/examples-debugging.html debug WebAssembly with LLDB

9.18 【今日阅读】https://github.com/xmake-io/xmake/tree/master/tests/projects/c%2B%2B/modules xmake c++ modules support

9.17 【今日阅读】https://www.zhihu.com/question/19570229/answer/1626066191 阅读优秀项目的源代码是程序员自我提高的重要途经，因此好的工具能够帮助你事半功倍。就像 Lua 这样的开源项目，官方文档可能你花一天就看完了，但是源代码很多人一个月都看不明白，而 好的工具可以帮助你加速这个过程。

9.16 【今日阅读】https://www.parseable.io/docs/introduction  Whenever I was tasked with setting up logging - I had to choose from search engines (masquerading as log stores) or exorbitantly priced SaaS. Search engines are natively CPU intensive and hence need frequent tuning. SaaS storage services essentially locked in the data and before you know, costs went out of hand. Both are not ideal.

9.15 【今日阅读】https://gittup.org/tup/ You can use tup anywhere you would use another build system (like make, or any of its derivatives). One reason you would want to use tup is if you like to update things very quickly. For example, if you typically execute a build in a subdirectory because it takes too long to figure out what to do when you execute the build from the top, you might want to look into tup.

9.14 【今日阅读】https://earthly.dev/blog/bazel-build/ I’ve never worked at Google or anywhere using Bazel to drive their builds, and so while I can walk through a Bazel tutorial, I felt like I was missing the sense of what using Bazel was like, both the day-to-day and migrating to Bazel. So I interviewed 6 Bazel experts1 and asked them what they like about Bazel, when they would use it, and what to expect or consider before doing a Bazel migration.

9.13 【今日阅读】https://neverworkintheory.org/2022/08/30/software-engineering-research-questions.html Software Engineering Research Questions

9.12 【今日阅读】https://kevinmahoney.co.uk/articles/files-that-change-together/ the more likely files are to be edited together, the closer in the file system hierarchy they should be.

9.11 【今日阅读】https://google.github.io/clusterfuzz/ As of May 2022, ClusterFuzz has found 25,000+ bugs in Google (e.g. Chrome) and 36,000+ bugs in over 550 open source projects integrated with OSS-Fuzz.

9.10 【今日阅读】https://tiemoko.com/blog/diff-fuzz/ Beyond the Borrow Checker: Differential Fuzzing

9.9 【今日阅读】https://api.csswg.org/bikeshed/?force=1&url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs The phrase "it doesn’t matter, just be consistent" has really harmed the C++ community more than it has helped. "A foolish consistency," if you will. Developers' desire to keep their codebase unique and "special" has held back the development of tooling when every user insists that a tool support their own custom style. https://bpt.pizza/docs/design.html

9.8 【今日阅读】https://www.youtube.com/watch?v=hkefPcWySzI roadmap of C++ module support in CMake and get an overview of the current set of features in CMake.

9.7 【今日阅读】https://www.youtube.com/watch?v=f6kb5t7FU3g DIFUZZRTL: Differential Fuzz Testing to Find CPU Bugs

9.6 【今日阅读】https://fuzzcheck.neocities.org/ Fuzzcheck’s goal is to be used as part of your development routine. You can quickly test small or complex function with it. It can find difficult corner-case bugs, minify complex test cases into easy-to-debug ones. It can find stack overflows and inputs that cause excessive computations or allocations.

9.5 【今日阅读】https://github.com/plasma-umass/coz Coz employs a novel technique we call causal profiling that measures optimization potential. This measurement matches developers' assumptions about profilers: that optimizing highly-ranked code will have the greatest impact on performance.

9.4 【今日阅读】https://jvns.ca/blog/2022/08/30/a-way-to-categorize-debugging-skills/ I thought the categorization was a very useful structure for thinking about how to get better at debugging, so I’ve reframed the five categories in the paper into actions you can take to get better at debugging.

9.3 【今日阅读】https://betterprogramming.pub/kubernetes-was-never-designed-for-batch-jobs-f59be376a338 Kubernetes is not a mere orchestration system. In fact, it eliminates the need for orchestration. The technical definition of orchestration is execution of a defined workflow: first do A, then B, then C. In contrast, Kubernetes comprises a set of independent, composable control processes that continuously drive the current state towards the provided desired state. It shouldn’t matter how you get from A to C. Centralized control is also not required. This results in a system that is easier to use and more powerful, robust, resilient, and extensible.

9.2 【今日阅读】https://mp.weixin.qq.com/s/KaTdLkMT8ko2GE3ROuPuRQ 基于服务上下游的思维，我把服务间依赖按以下维度进行耦合度分级：
Level4: 领域知识互为上下游，业务可用性互为上下游
Level3: 领域知识互为上下游, 业务可用性为单向上下游
Level2: 领域知识为单向上下游，业务可用性互为上下游
Level1: 领域知识为单向上下游，业务可用性为单向上下游

9.1 【今日阅读】https://www.foonathan.net/2022/08/malloc-interface/ A good API requests all information it needs (duh) and returns as much information it can provide (law of useful return). malloc() and free() don’t follow those principles, which make them less useful as they could be.

8.31 【今日阅读】https://msrc-blog.microsoft.com/2022/01/20/an_armful_of_cheris/ CHERI changes this. Every load or store instruction and every instruction fetch must be authorized by an architectural capability. Load and store instructions take a capability as the base instead of an integer address. The capability both identifies an address and grants access to a range of memory (including permissions, such as read, write, or execute).

8.30 【今日阅读】https://calebhearth.com/fan-out-vs-fan-in Design Your Codebase with Low Fan-out, High Fan-in Classes

8.29 【今日阅读】https://kevin.burke.dev/kevin/reddits-database-has-two-tables/ Reddit’s database has two tables

8.28 【今日阅读】https://github.com/stebunovd/blog/blob/master/contents/On-Estimates.md Ok, so estimates take their toll. They can be misleading, they can slow a team down and make developers uncomfortable, but we need them for project planning anyway, right? Well, not necessarily. Sometimes estimates are unavoidable, but in most cases, they are not required for project decisions.

8.27 【今日阅读】https://cs-syd.eu/posts/2022-08-22-how-to-deal-with-money-in-software Dealing with money in software is difficult and dangerous. This post contains an overview of the problems you will run into eventually when writing software that deals with money. It describes potential representations, relevant trade-offs, and recommends ways of correctly implementing common operations.

8.26 【今日阅读】https://lobste.rs/s/ezaucv/stop_saying_10x_developer The thing that so many “10x” type memes miss is that growth and seniority are increasingly less about the code you write and more about the impact you have on colleagues.

8.25 【今日阅读】https://zhuanlan.zhihu.com/p/387269513 https://zhuanlan.zhihu.com/p/394102530 摆在面前的一条路是DSA，一条路是SIMT，这是一个非常困难的选择。SIMT是NVidia已经趟过的老路，成熟可靠，但后劲不足，而且选择这条路意味着AI芯片最终收敛为GPU，GPU的所有天花板也能一眼望到头。DSA是目前看来arch未来的演进之路，但仍然处于探路的过程中，也依然有机会成为CPU和GPU之外的第三种独立的架构存在于历史长河中。

8.24【今日阅读】https://mp.weixin.qq.com/s/lJAbzU43RJU-YLFMfiM__w 该平台前后已经历四五家供应商历时七八年的不断修改，可维护性极差。在进行升级改造的同时，我们更“有幸”直接承担了该系统的各项线上运维工作，真真切切体验了陷入“软件泥潭”的感受。

8.23 【今日阅读】https://zhuanlan.zhihu.com/p/555275693 网上有个段子，说建筑工程师不会轻易答应会给摩天大楼增加一个地下室，但代码开发工程师却经常在干这样的事，并且总有人会对你说“这个需求很简单”。

8.22 【今日阅读】https://docs.gitlab.com/ee/user/application_security/coverage_fuzzing/ Coverage-guided fuzz testing sends random inputs to an instrumented version of your application in an effort to cause unexpected behavior. Such behavior indicates a bug that you should address. GitLab allows you to add coverage-guided fuzz testing to your pipelines. This helps you discover bugs and potential security issues that other QA processes may miss.

8.21 【今日阅读】https://zdimension.fr/how-i-learned-to-stop-worrying-and-love-macros/ Rust supports two kinds of macros: declarative macros and procedural macros.

8.20 【今日阅读】https://github.com/python/cpython/pull/95908 From CPython 3.12, the official build configuration now supports using LLVM-BOLT as the post-link binary optimizer. It shows that 1-5% performance improvement from pyperformance benchmark.

8.19 【今日阅读】https://mp.weixin.qq.com/s/8vls4RqGn2ebySyDYpPIwQ 大量异步事件导致系统难以维护，系统存在数据不一致性以及莫名其妙的性能问题

8.18 【今日阅读】https://neon.tech/ Neon allows to instantly branch your Postgres database to support a modern development workflow. You can create a branch for your test environments for every code deployment in your CI/CD pipeline.

8.17 【今日阅读】https://www.youtube.com/watch?v=mkkaAWNE-Ig Exceptions the Other Way Round - Sean Parent

8.16 【今日阅读】https://oooops.dev/2021/07/30/surviving-continuous-deployment-in-distributed-systems/ as each change we make now goes immediately to production, it has the potential to affect a complex web of services. These services depend on each other in often intricate ways, and service interdependencies are among the hardest things to test. One mistake in a commit which our pipelines don’t catch, and production goes down. Or data is corrupted.

8.15 【今日阅读】https://cprimozic.net/blog/boolean-logic-with-neural-networks/ A state machine, turing machine, or other program that generates a string like "0101010101010101010101" by hard-coding it and reciting is more complex than one that uses a loop and counter, for example. In the same way, a neural network that learns how to identify birds by memorizing the pictures of all birds in the training set will be much more complex - and much less likely to be formed - than one that uses actual patterns derived from shared features of the images to produce its output.

8.14 【今日阅读】https://github.com/rochus-keller/BUSY/blob/main/README.md Compared to other build systems like CMake, QMake, Meson or GN, BUSY is characterized by a statically typed build specification language, and by the possibility to build a project directly from scratch without any further requirements to the host system; BUSY is so lean that it is even suited to be directly integrated with the source tree of a project.

8.13 【今日阅读】https://massimo-nazaria.github.io/blog/2022/02/10/avoid-spaghetti-code-with-scope-minimization.html how to prevent the phenomenon of spaghetti code just by minimizing the visibility of variables

8.12 【今日阅读】https://buildingblock.ai/cpp20-modules-bazel How to Use C++20 Modules with Bazel and Clang

8.11 【今日阅读】https://blog.alexgilleran.com/test-against-what-wont-change/ This approach is pretty close to writing "mostly integration" tests, or Kent C. Dodds' Test Trophy, but rather than trying to define "integration" or "unit", my preference is to focus on core principles: you should only have to change your tests when you change what your system does, not how it does it, and the easiest way to make that happen is to write them against the interfaces that your system presents to either other systems or to the user.

8.10 【今日阅读】https://www.alexedwards.net/blog/the-fat-service-pattern In this post I'd like to talk about one of my favorite architectural patterns for building web applications and APIs in Go. It's kind of a mix between the service object and fat model patterns — so I mentally refer to it as the 'fat service' pattern

8.9 【今日阅读】https://www.ralfj.de/blog/2022/08/08/minirust.html The purpose of MiniRust is to describe the semantics of an interesting fragment of Rust in a way that is both precise and understandable to as many people as possible. These goals are somewhat at odds with each other – the most precise definitions, e.g. carried out in the Coq Proof Assistant, tend to not be very accessible. English language, on the other hand, is not very precise. So my compromise solution is to write down the semantics in a format that is hopefully known to everyone who could be interested: in Rust code.

8.8 【今日阅读】https://buttondown.email/j2kun/archive/monorepos-and-forced-migrations/ But even if you balk at the line I drew between monorepos and Cloud adoption, the question still stands why mandated migrations are so common at Google. Why can’t Google just support things and maintain backwards compatibility?

8.7 【今日阅读】https://www.47deg.com/blog/why-types/ Making implicits explicit, Dependencies between values, Two-and-a-half flavors, Proving stuff to the compiler

8.6 【今日阅读】https://thenumb.at/Autodiff/ In computer graphics, differentiable rendering, differentiable physics, and neural representations are all poised to be important tools going forward.

8.5 【今日阅读】https://embeddeduse.com/2022/08/03/applying-tdd-to-hal-drivers-with-memory-mapped-i-o/ A client recently asked me to help them get a legacy HAL driver under test. They want to use TDD to maintain and extend the driver. We ran into a couple of problems, because the tests run on a 64-bit computer, whereas the production code runs on a 32-bit microcontroller. I’ll explain the problems and how to solve them.

8.4 【今日阅读】https://specbranch.com/posts/one-big-server/  It is often easier and more efficient to scale vertically instead. Using one big server is comparatively cheap, keeps your overheads at a minimum, and actually has a pretty good availability story if you are careful to prevent correlated hardware failures.

8.3 【今日阅读】https://github.com/SanderMertens/flecs/blob/d6b98939f14513e716e397a0f8a468057530554c/docs/Quickstart.md Something is called an ECS when it:
* Has entities that uniquely identify objects in a game
* Has components which are datatypes that can be added to entities
* Has systems which are functions that run for all entities matching a component query

For example, a game has a Move system that has a query with two components, Position, Velocity. When the system is ran it is dynamically matched with all entities that have at least these two components.

8.2 【今日阅读】https://news.ycombinator.com/item?id=32317441 At about 40 I shaved my epic beard, took graduation dates off my resume and limited it to about the last 10 years of work. Fresh shave and haircut for any f2f interview. So far so good.

8.1 【今日阅读】https://github.com/remesh-js/remesh A DDD framework for large and complex TypeScript/JavaScript applications

7.31 【今日阅读】https://itnext.io/you-dont-need-microservices-2ad8508b9e27 The monolith should remain the default choice for new, small, and medium-sized engineering teams. Microservices are still an option, but you should have compelling context-specific reasons to justify their use.

7.30 【今日阅读】https://tipi.build/documentation/02-dependencies/ Tipi enables comfortable consumption of dependencies from multiple source like GitHub.com repositories or CMake Hunter provided packages.

7.29 【今日阅读】https://maskray.me/blog/2020-11-08-stack-unwinding#%E4%B8%AD%E6%96%87%E7%89%88  https://maskray.me/blog/2020-12-12-c++-exception-handling-abi#%E4%B8%AD%E6%96%87%E7%89%88 对比一下 https://mccue.dev/pages/7-27-22-c-errors The different ways to handle errors in C

7.28 【今日阅读】https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await If you think about it, the coroutine frame acts as a kind of really high-performance arena memory allocator. The compiler figures out at compile time the total arena size it needs for all local variables and is then able to allocate this memory out to local variables as required with zero overhead! Try beating that with a custom allocator ;)

7.27 【今日阅读】https://webdevelopmenthistory.com/1993-cgi-scripts-and-early-server-side-web-programming/ But another theme of web development is that things don’t stay still for long! 1994 saw the emergence of a new scripting language that was based on CGI: PHP, which initially stood for “Personal Home Page Tools.” Over time, PHP became a replacement for Perl CGI scripts in many cases. I’ll delve into that story in the next post in this series about server-side web development.

7.26 【今日阅读】https://gigamonkeys.com/flowers/ There is one caveat to all this, however. In order for engineering effectiveness engineers to be able to boost effectiveness across all of engineering, things need to be standardized. As we just saw, the big investments in engineering effectiveness work only starts to pay off when you are doing the work for lots of engineers.

7.25 【今日阅读】https://embeddedartistry.com/blog/2020/03/02/why-we-estimate/ First: we are creatures that live in a world dominated by Time. None of us can stop, slow, or reverse the unyielding march of Time. Second: we do not operate in the world alone. Estimates are one tool that we use to facilitate coordination and cooperation.

7.23 【今日阅读】https://www.sqlite.org/testing.html How SQLite Is Tested

7.22 【今日阅读】https://htmx.org/essays/spa-alternative/ It is particularly difficult to do in the technology world , where the being left behind technically is not only a threat to our ego, but also to our employment. "No One Ever Got Fired For Using React" is today's "No One Ever Got Fired For Buying IBM" That's a reality that we must accept, even if we feel that React/etc.

7.21 【今日阅读】https://news.ycombinator.com/item?id=25867693 Why isn't differential dataflow more popular?

7.20 【今日阅读】https://brandur.org/soft-deletion Instead of keeping deleted data in the same tables from which it was deleted from, there can be a new relation specifically for storing all deleted data, and with a flexible jsonb column so that it can capture the properties of any other table

7.19 【今日阅读】https://sluongng.hashnode.dev/bazel-caching-explained-pt-2-bazel-in-memory-cache In my experience, between the 3 caching layers of Bazel, In-Memory Cache is the easiest one to miss. It's not common for CI Service Providers to be offering an in-memory caching system, especially when local disk cache and / or remote cache could already speed your CI Pipelines in the open source ecosystem down to merely a minute. Therefore, engineers don't often think that they need in-memory cache in CI, just because most existing solutions in the wild don't offer one. However, in the enterprise monorepo context, in-memory cache sometimes is the only way to keep things reasonable. It is applied everywhere: in production services, in Data / ML Pipelines, etc... and now, CI builds.

7.18 【今日阅读】https://engineering.q42.nl/android-server-driven-ui/ Android Server Driven UI: How we were able to build a native Android app in record time as well as iOS and Web applications, by sharing business logic and UI components.

7.17 【今日阅读】https://inqlab.net/2022-07-01-geopub-a-multi-model-database.html how a database can support efficient graph, geo-spatial and full-text search queries at the same time - a multi-modal database. This is an important step towards search and discovery of local knowledge.

7.16 【今日阅读】https://github.com/Re-engineering-Domain-Driven-Design/Accounting/blob/main/README.zh-cn.md Transaction的不同生命周期，可能极度违反直觉。因为从业务概念上讲，Account应该聚合Transaction才对。这种业务上的聚合关系，我们通过URI来表示。 也就是对于Transaction而言，它的URI是/customers/{cid}/accounts/{aid}/transactions/{tid}。 而不是/customers/{cid}/source-evidences/{sid}/transactions/{tid}。 将业务聚合与生命周期混为一谈，是领域驱动设计的顽疾。

7.15 【今日阅读】https://dragly.org/2017/03/31/uniform-call-syntax/ Uniform call syntax in C++ today 把行为从类定义里面抽出来

7.14 【今日阅读】https://news.ycombinator.com/item?id=13594794 One common anti-pattern is that "event driven" can lead to a push architecture that works on paper, but is unreliable in practice. Then you rewrite from a push based system to a pull based system, and all of your complex edge cases disappear.

7.13 【今日阅读】https://zhuanlan.zhihu.com/p/266510840 用Airbnb一位朋友的话来说：大家都在浪费很多时间研究build怎么写，出了问题也不知道怎么调。经常升级个版本就build break了；monorepo里跑个bazel build 就可以泡杯咖啡扯个蛋；尽管如此，Bazel仍然是当前开源Build System里最先进也最代表着未来方向的产品

7.11 【今日阅读】https://www.ncameron.org/blog/complexity/ complexity affects users by increasing cognitive load. That cognitive load might mean more things to keep in our working memory, which could be due to breadth (e.g., more variables in a function, more branches in a conditional, or more possible implementations of an interface) or depth (e.g, to understand some function call we have to read its implementation, and functions it calls).

7.10 【今日阅读】https://gordonc.bearblog.dev/dry-most-over-rated-programming-principle/ 1. DRY is misused to eliminate coincidental repetition 2. DRY creates a presumption of reusability 3. DRY is a gateway drug to unnecessary complexity

7.9 【今日阅读】https://gbracha.blogspot.com/2022/06/the-prospect-of-execution-hidden.html You can literally reuse your object serializer as a deployment format. Serializing data and serializing code are one and the same.

7.8 【今日阅读】https://www.baldurbjarnason.com/2022/more-better-web-apps/ 

* They are describing how things are done where they work and assume that if you’re describing something different you must be describing it wrong or not following your place of employment’s best practices.
* They are describing how they’d prefer to work and are assuming that your different take means that you think that they’re making a big mistake.
* They are educators teaching a specific approach to solving a specific problem. They’re aware that there are often many different solutions to each problem but are describing the one they teach. They also are probably assuming that you think they’re teaching the wrong approach for bad reasons.
* They are testing out different approaches and weighing the pros and cons of each, with data. They’re assuming that you can’t make good decisions in a vacuum. Which is a good assumption, admittedly.
* They are concerned about the long-term sustainability of the field. They keep encountering highly flawed websites or web apps and are assuming that regular web devs can do something about it.

7.7 【今日阅读】https://josephg.com/blog/3-tribes/ You are a poet and a mathematician. Programming is your poetry; You are a hacker. You make hardware dance to your tune; You are a maker. You build things for people to use

7.6 【今日阅读】https://lobste.rs/s/5ozh2p/write_code_like_you_just_learned_how It’s extremely difficult to be simultaneously concerned with the end-user experience of whatever it is that you’re building and the architecture of the program that delivers that experience. I think the only way to pull it off is to simply not care about the latter.

7.5 【今日阅读】https://github.com/redwood/redwood Redwood is a highly-configurable, distributed, realtime database that manages a state tree shared among many peers. Redwood is also an application server. Developers can store and update assets (HTML, Javascript, images) directly in the state tree. For many types of applications, you may not need a separate backend server at all.

7.4 【今日阅读】https://josephg.com/blog/crdts-go-brrr/ 5000x faster CRDTs: An Adventure in Optimization

7.3 【今日阅读】https://marijnhaverbeke.nl/blog/facets.html This post tries to explain CodeMirror's (a code editor library) approach to solving extension problem

7.2 【今日阅读】http://axisofeval.blogspot.com/2011/04/whats-condition-system-and-why-do-you.html What's a condition system and why do you want one?

7.1 【今日阅读】https://webglfundamentals.org/webgl/lessons/webgl-scene-graph.html If you move the earth the moon will move with it. If you move a galaxy all the stars inside will move with it.  Model the rule of "state dependency" (a.k.a Newton's law of motion).

6.30 【今日阅读】https://www.foonathan.net/2022/06/cmake-fetchcontent/#content FetchContent is a really convenient way of managing dependencies. But you as a library authors can do a couple of things to make it even easier for the end user: Only define minimal targets when the project is included as a subdirectory. Provide minimal zipped archive of sources that users can download instead of the entire repository. Use GitHub actions to automatically create the archive for each release.

6.29 【今日阅读】https://mike.cloud/tech%20industry/2022/06/24/autonomous-teams.html If you keep an eye on German automotive companies, you will see a pattern. Their software is a huge mess and they have trouble finding and keeping developers, which leads to a high turnover rate, that amplifies existing issues.

6.28 【今日阅读】https://acko.net/blog/react-the-missing-parts/ No-hooks and Early Return，Component Morphing，useMemo vs useEffect + setState，and some wild Yeet-Reduce results

6.27 【今日阅读】https://roman.pt/posts/dont-let-dicts-spoil-your-code/ Keep an eye on your dicts. Don’t let them take control of your application. As with every piece of technical debt, the further you postpone introducing proper data structures, the more complex the transition becomes.

6.26 【今日阅读】https://lobste.rs/s/phqsxk/hay_ain_t_yaml_custom_languages_for_unix innovations in this space of interleaving code and data in interesing new ways

6.25 【今日阅读】http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/ I believe that naming things is one of the most fundamental tasks we do when programming. Names are the structure we impose on the formless sea of bits that is computing.

6.24 【今日阅读】https://benjamincongdon.me/blog/2022/06/22/Mental-Model-Difficult-Problems-vs.-Hard-Work/  there are problems that are solvable by throwing a lot of human-hours at it (“Hard Work”), and problems that are not a function of raw work hours, but rather require dealing with ambiguity (“Difficult Problems”).

6.23 【今日阅读】https://www.youtube.com/watch?v=Q2p_iqjfekI F# modules as business logic scopes, controlling business logic visibility via modules

6.22 【今日阅读】https://www.youtube.com/watch?v=4YTfxresvS8 Raph Levien presented an overview of his new framework for creating a GUI in Rust. He uses data oriented design principles and ideas derived from entity component systems in order to create a native-looking GUI for Xi Editor. This talk explores this approach as well as potential alternatives and discusses the pros and cons of each.

6.21 【今日阅读】https://www.tonymarston.net/php-mysql/dependency-injection-is-evil.html A common reason people give for preferring dependency injection is that it makes testing easier. The point here is that to do testing, you need to easily replace real service implementations with stubs or mocks. However there is really no difference here between dependency injection and service locator: both are very amenable to stubbing. I suspect this observation comes from projects where people don't make the effort to ensure that their service locator can be easily substituted. This is where continual testing helps, if you can't easily stub services for testing, then this implies a serious problem with your design.

6.20 【今日阅读】https://lobste.rs/s/eahdc8/dora_metrics_right_answer_measuring The language choices here reflect what I see across the industry. The term “high-performing” is especially pervasive. Whenever I dig into what people mean by this it usually means “hits management’s projections” or in the most general cases “ships often”. The causality is rarely stated.

6.19 【今日阅读】https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7 OOP makes the problem of code organization even worse by scattering state all over the program. The scattered state is then shared promiscuously between various objects.

6.18 【今日阅读】https://textslashplain.com/2022/05/18/thoughts-on-impact/ We try to break impact down into three rings: 1) Your own accomplishments, 2) How you built upon the ideas/work of others, and 3) How you contributed to others’ impact. The value of #1 and #3 is pretty obvious, but #2 is just as important– Microsoft now strives to act as “One Microsoft”. This represents a significant improvement over what was once described to prospective employees as “A set of competing fiefdoms, perpetually at war” and drawn eloquently by Manu Cornet

6.17 【今日阅读】https://github.com/Re-engineering-Domain-Driven-Design/Accounting/blob/main/README.zh-cn.md 
Re-engineering Domain Driven Design

6.16 【今日阅读】https://acko.net/blog/on-variance-and-extensibility/ Making code reusable is not an art, it's a job

6.15 【今日阅读】https://blog.ploeh.dk/2022/06/13/some-thoughts-on-naming-tests/ If the name and test code disagree, which one is right?

6.14 【今日阅读】https://mp.weixin.qq.com/s/RnYJ-hyA2NHaVPlDoY_kZg “部门间竞争太激烈，资源不共享，资源浪费严重。”一位大厂员工在脉脉上吐槽，“不断在上一个项目上重复造轮子，输了之后换下一波人，轮子太多，车不够用。”

6.13 【今日阅读】https://thevaluable.dev/cohesion-coupling-guide-examples/ Cohesion and Coupling in Software with Examples

6.12 【今日阅读】https://www.youtube.com/watch?v=xOsmO4Gnj6c 1. Find a stronghold 2. Analyse stack 3. Start from I/O 4. Decoupling 5. Padded-room

6.11 【今日阅读】https://blog.ecosta.dev/en/tech/cpp-modules-with-clang this article showed how to use C++ modules with Clang, and data for this simple test shows the main benefit of them: the pre-compilation of <iostream> inside M3 only impacts M3 itself. Consumers of it are only positively impacted: M3C takes 6x less to compile, when compared to M3, and it can inline usages of "std::cerr" with minimal penalty.

6.10 【今日阅读】https://nolanlawson.com/2022/06/09/the-collapse-of-complex-software/ One thing working in complexity’s favor, though, is that engineers like complexity. Admit it: as much as we complain about other people’s complexity, we love our own. We love sitting around and dreaming up new architectural diagrams that can comfortably sit inside our own heads

6.9 【今日阅读】https://zhuanlan.zhihu.com/p/526164614 单向数据流最让人迷恋的地方在于减少需要程序员手工管理的 mutable state 的个数。vdom，计算属性和effect 有的时候还是重算太多了。使得我们无法实现“真正的”单向数据流。还有第四种方案，标脏。以及第五种方案，暴力重算。

6.8 【今日阅读】https://eli.thegreenplace.net/2022/performance-of-coroutine-style-lexers-in-go/ Back in 2011, Rob Pike gave a talk on the topic of Lexical Scanning in Go, where he presented an interesting approach to lexical analysis with coroutines (implemented via goroutines communicating over a channel). Since I've been pondering the connection between coroutines and state machines in the past, Rob's talk inspired me to try approximating this approach in Python using sub-generators.

6.7 【今日阅读】http://gameprogrammingpatterns.com/component.html  Any programmer trying to make a change in code like that will need to know something about physics, graphics, and sound just to make sure they don’t break anything.

6.6 【今日阅读】https://fasterthanli.me/articles/the-curse-of-strong-typing The curse of strong typing

6.5 【今日阅读】https://zhuanlan.zhihu.com/p/524164859 状态同步的模式

6.4 【今日阅读】http://bitsquid.blogspot.com/2011/01/managing-coupling.html Ideally, each system should be completely isolated. The effect system should be the only system manipulating effects and it shouldn’t do anything else. It should have its own update() call just for updating effects. No other system should care how the effects are stored in memory or what parts of the update happen on the CPU, SPU or GPU. A new programmer wanting to understand the system should only have to look at the files in the effect_system directory. It should be possible to optimize, rewrite or drop the entire system without affecting any other code.  http://bitsquid.blogspot.com/2011/09/managing-decoupling-part-4-id-lookup.html  using IDs to refer to objects owned by other systems

6.3 【今日阅读】https://motion.dev/guides/performance 基于 state 的分层解耦合。你对浏览器 DOM 不同属性的读或者写（https://csstriggers.com/），对于你来说都是普通的数据结构改动，但是引起的浏览器侧的重计算是完全不同的。浏览器通过 DOM 这么一层 state 把 computation 进行了解耦合。可以理解为每个 DOM property 名相当于 kafka 的 topic，你对 DOM 属性的操作，会往对应的 kafka topic 投递消息，不同的后续计算是订阅这个 topic 来触发的。

6.2 【今日阅读】https://clivethompson.medium.com/programming-isnt-hard-but-it-s-frustrating-6cb740085243 A very high tolerance for daily, grinding frustration. That’s because most programming isn’t so much creating code as debugging it. You write a function, you test it, and — very often — it doesn’t work. when you’re stuck on a coding problem, it feels much more like a deeply personal failure: My inability to follow a logical sequence through.

6.1 【今日阅读】https://sethmlarson.dev/blog/people-in-your-software-supply-chain For many open source consumers the "logical units" being depended on are libraries. However, the libraries themselves are only a product of what consumers are actually depending on: people.

5.31 【今日阅读】https://semgrep.dev/docs/writing-rules/pattern-examples/ Semgrep is an open-source tool with a simple syntax for writing rules: if you can write code, you can write a Semgrep rule — no program analysis PhD required! To our knowledge, the only other tool with the explicit goal of allowing custom rules is GitHub’s proprietary tool, CodeQL. https://semgrep.dev/r

5.30 【今日阅读】https://thevaluable.dev/tags/complexity/ Measuring Software Complexity

5.29 【今日阅读】https://www.notboring.co/p/apis-all-the-way-down by one estimate, even before the pandemic, Stripe was generating $350 million in revenue from Shopify alone -- and that Shopify would inevitably get sick of paying Stripe and build their own payments solutions.

5.28 【今日阅读】https://www.youtube.com/watch?v=kPbRDn5Fg0Y 过去一个 highcharts 组件要同时负责 svg格式化，dom操作，字体颜色，动画效果。现在可以把每个侧面的拆开来提供可复用的lib，d3只负责svg，react只负责dom，tailwind只负责字体颜色，framer-motion只负责动画，各司其职。最终写出来的声明式的代码 Diff from "Building an Animated Line Chart with d3, React and Framer Motion" https://www.youtube.com 就等同于给 highcharts 传递的 options。

5.27 【今日阅读】https://news.ycombinator.com/item?id=31515938 Spark is not a database, certainly not an RDBMS. A big distributed database/storage layer into which I can write queries in my chosen language... The author seems to be suggesting that Databricks/Snowflake are selling "storage", "language integration", and "a better Postgres", which is like saying that Toyota sells an air conditioner, entertainment unit, and leather chairs. Technically right... but missing the car for the parts.

5.26 【今日阅读】https://understandlegacycode.com/blog/key-points-of-legacy-code-programmer-toolbox/ The key points of The Legacy Code Programmer's Toolbox

5.25 【今日阅读】https://markus.oberlehner.net/blog/refactoring-a-house-software-architecture-is-architecture-after-all/ First misconception: changing software is cheap; Second misconception: buildings are static;

5.24 【今日阅读】https://www.youtube.com/watch?v=Dq2ftPf3sn4 Add Nx to an Existing Monorepo https://nx.dev/configuration/projectjson Projects can be configured in package.json

5.23 【今日阅读】https://neverworkintheory.org/ It might work in practice, but it will never work in theory. People have been building complex software for over sixty years, but until recently, only a handful of researchers had studied how it was actually done. Many people had opinions—often very strong ones—but most of these were based on personal anecdotes or the kind of "it's obvious" reasoning that led Aristotle to conclude that heavy objects fall faster than light ones.

5.22 【今日阅读】https://www.reddit.com/r/programming/comments/uu5a5k/why_building_software_takes_time/ Why building software takes time

5.21 【今日阅读】https://justine.lol/ftrace/ One of my favorite features of the Cosmopolitan Libc runtime is its --ftrace flag that logs C function calls. The Cosmopolitan Libc _start() function starts by intercepting the --ftrace flag. If it exists, then it opens and sorts of the symbol table from the elf binary. Then it changes the protection of memory so it's able to iterate over the program's memory to look for nop instructions it can mutate.

5.20 【今日阅读】https://www.datadoghq.com/blog/engineering/introducing-husky/ The concepts of shards and replicas have mostly disappeared from the system. In addition, we make no distinction between “historical” data and “fresh” data anywhere in the architecture.

5.19 【今日阅读】https://zhuanlan.zhihu.com/p/515247384 https://juejin.cn/post/7044054733186662407 奥创实际上就是，由后端告诉前端如何去渲染；将页面组件化，每种组件具有相应的职责；具有组件可复用的能力的前后端统一的交互方式。

5.18 【今日阅读】https://en.wikipedia.org/wiki/Expression_problem The expression problem is a challenge problem in programming languages that concerns the extensibility and modularity of statically typed data abstractions. The goal is to define a data abstraction that is extensible both in its representations and its behaviors, where one can add new representations and new behaviors to the data abstraction, without recompiling existing code, and while retaining static type safety (e.g., no casts). It exposed deficiencies in programming paradigms and programming languages, and it is still not definitively solved, although there are many proposed solutions.

5.17 【今日阅读】https://mp.weixin.qq.com/s/OrekHmMrn8UlisTrvt3MNA 实际构建的项目 = 改动项目 + 改动项目的 Dependencies + Dependencies 的依赖 + 改动项目的 Dependents + Dependents 的依赖

5.16 【今日阅读】https://medium.com/airtable-eng/stateful-model-based-database-fuzzing-eacffb4d7337 Appendix: An obscure bug found by the fuzzer, Here is an example bug that our fuzzer found. You don’t need to understand all the details — we mainly think it’s important to focus on the complexity of the situation.

5.15 【今日阅读】https://blog.logrocket.com/comparing-rust-supply-chain-safety-tools/ Comparing Rust supply chain safety tools

5.14 【今日阅读】https://onlinelibrary.wiley.com/doi/10.1002/spe.2874 Forges are online collaborative platforms to support the development of distributed open source software. While once mighty keepers of open source vitality, software forges are rapidly becoming less and less relevant.

5.13 【今日阅读】https://en.wikipedia.org/wiki/Temporal_database A challenging issue is the support of temporal queries in a transaction time database under evolving schema. In order to achieve perfect archival quality it is of key importance to store the data under the schema version under which they first appeared. However, even the most simple temporal query rewriting the history of an attribute value would be required to be manually rewritten under each of the schema versions, potentially hundreds as in the case of MediaWiki [1]. This process would be particularly taxing for users. A proposed solution is to provide automatic query rewriting,[7][8] although this is not part of SQL or similar standards.

5.12 【今日阅读】https://lobste.rs/s/jrolak/announcing_d1_our_first_sql_database Litestream author here. I think SQLite has trended recently because more folks are trying to push data to the edge and it can be difficult & expensive to do with traditional client/server databases.

5.11 【今日阅读】https://craftofcoding.wordpress.com/2022/03/28/ever-wondered-why-goto-is-considered-harmful/ The flowchart on the left has 72 unique paths. The flowchart on the right with the dotted line signifying an unstructured jump has 93,748,416,840 unique paths

5.10 【今日阅读】https://doriantaylor.com/the-symbol-management-problem In software, and especially in Web development, you will find yourself dealing with a number of symbols, tokens, slugs—identifiers intended to pick out, demarcate, and differentiate different pieces of content for different kinds of processing

5.9 【今日阅读】https://erikbern.com/2022/04/05/sigma-driven-project-management-when-is-the-optimal-time-to-give-up.html So where does the σ come from? My thesis for this blog post is that σ is an inherent property of the type of risk you have in your project portfolio, and that different values for σ warrants very different types of project management. Low σ means low uncertainty and means we should almost always finish projects. High σ means high uncertainty — more like a research lab — and means large risks of a huge blowup, which also means we should abandon lots of projects.

5.8 【今日阅读】https://zhuanlan.zhihu.com/p/507150586 市面上大部分数据仓库都需要用户在建表时指定分区字段，预先判断数据的分布情况，这无疑加重了用户的使用负担，如果查询模式跟分区无关，做查询优化则非常困难，Auto Clustering 则很好的解决了这些问题。

5.7 【今日阅读】https://www.maguangguang.xyz/bff-governance 这是在BFF暴露给前端的接口，实现过程中需要调用后端10+个服务，进行几十次的服务间调用。在这几十次服务间调用过程中，有大量的读操作，以及近10次的跨服务写操作，读操作主要为了满足写操作的数据组装要求。

5.6 【今日阅读】https://github.com/taowen/vite-howto It is about how to split application into files/packages, how to use TypeScript to ensure compatibility, how to use Vite to link them back (either statically or dynamically).

5.5 【今日阅读】https://zhuanlan.zhihu.com/p/508877002 架构设计-复用是邪恶的

5.4 【今日阅读】https://quanttype.net/posts/2022-05-02-schema-migrations.html Schema migrations and avoiding downtime

5.3 【今日阅读】https://commaok.xyz/post/perf_files/ Linus’s Famous Law: “Given enough eyeballs, all bugs are shallow.”
Linus’s Less Famous Law: “Files grow.”

5.2 【今日阅读】https://linearb.io/dora-metrics/ LinearB is a free tool that integrates with your Git and project management system to provide team and organization level DORA metrics within minutes.

5.1 【今日阅读】https://flameeyes.blog/2022/04/26/engineering-jargon-yaks/ if not "Yak shaving", what you should do instead.

4.30 【今日阅读】https://time.geekbang.org/column/article/513599 观察到一个现象就是教你重构教你单元测试的教程一般都是读操作。写操作怎么弄？怎么把写操作转换成更易于测试的读操作？

4.29 【今日阅读】https://mp.weixin.qq.com/s/7VlXBl9syw2ppiR3x237bA 基于已有组件，组装集成环节做的事情就是选择需要的组件，填充配置，一旦组装结果被保存之后，即完成系统的集成，不再需要构件和部署。填充好配置就可以发布了，系统运行时，多个产品功能在运行时候共享一套组件实例，差别在于执行组件的组合和配置不同。这一点是通过前文提到过的业务身份来实现的，不同业务身份关联不同的组件组装DSL及组件用户配置，最终实现差异化功能组装和执行。

4.28 【今日阅读】https://news.ycombinator.com/item?id=31176910 回忆早年的web开发

4.27 【今日阅读】https://vkcom.github.io/kphp/various-topics/type-inferring-examples.html kphp: php type inference

4.26 【今日阅读】https://lobste.rs/s/en6d6k/inventing_postscript_tech_took_pain_out The real value of something like PostScript or PDF is not for communicating with a printer, it’s for communicating with a publisher. Being able to serialise your printable output in a (relatively) small file that does not include any printer-specific details (e.g. exactly what the right dithering patterns should be to avoid smudging on this technology, what the exact mix of ink colours is), is a huge win. You wouldn’t want to send every page as a fully rasterised image, because it would be huge and because rasterisation bakes in printer-specific details.

HP’s big innovation in this space was to realise that these were separate languages. PCL was a far better language for computer-printer communication than PostScript and let HP ship printers with far slower CPUs and less RAM than competitors that spoke PostScript natively. At the same time, nothing stopped your print server ( a dedicated machine or a process on the host) from accepting PostScript and converting it to PCL.****

4.25 【今日阅读】https://jmmv.dev/2022/04/rust-traits-and-dependency-injection.html Rust traits and dependency injection

4.24 【今日阅读】https://www.cybertec-postgresql.com/en/pg_rewrite-postgresql-table-partitioning/ pg_rewrite is a good method to turn existing tables into PostgreSQL partitions. It only needs a short lock, which makes it superior to the long and extensive table locking needed by the PostgreSQL core.

4.23 【今日阅读】https://dev.to/taowen/what-makes-code-slow-to-execute-1d6j where code executes matters

4.22 【今日阅读】https://www.infoq.com/articles/implementations-patterns-br/ Local consequences; Minimize repetition; Logic and Data together; Symmetry; Declarative Expression; Rate of Change

4.21 【今日阅读】https://adamwathan.me/css-utility-classes-and-separation-of-concerns/ Taking a component-first approach to CSS means you create components for things even if they will never get reused. This premature abstraction is the source of a lot of bloat and complexity in stylesheets. Take a navbar for example. How many times in your app do you rewrite the markup for your main nav?

4.20 【今日阅读】https://dev.to/brentmitchell/after-5-years-im-out-of-the-serverless-compute-cult-3f6d After 5 years, I'm out of the serverless compute cult

4.19 【今日阅读】https://caseymuratori.com/blog_0015 I look at programming as having essentially two parts: figuring out what the processor actually needs to do to get something done, and then figuring out the most efficient way to express that in the language I’m using.

4.18 【今日阅读】http://www.covingtoninnovations.com/mc/WriteThinkLearn.pdf How to Write More Clearly, Think More Clearly, and
Learn Complex Material More Easily

4.17 【今日阅读】https://developers.redhat.com/articles/2022/04/12/state-static-analysis-gcc-12-compiler So for GCC 12, I've implemented enough support for inline assembly for the analyzer to handle cases like this. I don't attempt to actually parse and interpret the assembly code; I just needed to add enough heuristics to recognize that the result of the inline assembler isn't going to change between the two calls to array_index_mask_nospec. With this enhancement, the analyzer is able to figure out that the result from wdev_to_wvif is the same both times, fixing the false positive the analyzer had previously returned.

4.16 【今日阅读】https://github.com/racket/racket/pull/4179 Running make currently triggers a Rube-Goldberg-style contraption: makefiles that run scripts that generate twisty sets of makefile macros that trick make into running compilers and other makefiles and... It's fragile, difficult update, and everything has to be done twice to cover Unix and Windows. See also Non-recursive Make Considered Harmful: Build Systems at Scale; our makefiles don't currently include $$$$, but probably because I've found only worse ways to do things.

4.15 【今日阅读】https://interjectedfuture.com/destroyed-at-the-boundary/ Shared mutable state invites complexity into our programs. Programming languages help with this complexity inside a program, but not across network boundaries between programs.

4.14 【今日阅读】https://bytebase.com/blog/what-is-database-schema-drift Database schema drift or just schema drift is the case where the actual schema in the live database (the actual state) is different from the source of truth (the desired state).

4.13 【今日阅读】https://htmx.org/essays/locality-of-behaviour/ The primary feature for easy maintenance is locality: Locality is that characteristic of source code that enables a programmer to understand that source by looking at only a small portion of it.

4.12 【今日阅读】https://kislayverma.com/organizations/reduce-collaboration-by-good-design/ What if we think of all software work as building a product? My customers, who happen to be other engineers in this context, should be able to explore and understand my product, play around with it, and then finally sign up for it with minimum human intervention.

4.11 【今日阅读】https://mp.weixin.qq.com/s/ZtMGKK0F2-jtkK0NBdmguQ 不稳定测试用例是自动化测试的主要挑战之一（Part One）

4.10 【今日阅读】https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/   The title is the thesis: the Zig programming language has function colors. And in the rest of this post, I will prove that and try to explain what it means for programmers using Zig.

4.9 【今日阅读】https://logicmag.io/clouds/agile-and-the-long-crisis-of-software/ a long-running wrestling match between what managers want software development to be and what it really is, as practiced by the workers who write the code. Time and again, organizations have sought to contain software’s most troublesome tendencies—its habit of sprawling beyond timelines and measurable goals—by introducing new management styles.

4.8 【今日阅读】https://caseymuratori.com/blog_0024 I think the Granny 2.x API went a long way towards demonstrating how an API can be thoughtfully designed to allow smoothly integrating one complex system with another in a way that doesn’t sacrifice performance or squander resources.

4.7 【今日阅读】https://victor.4devs.io/en/architecture/integration-database.html Integration database and why you should avoid it

4.6 【今日阅读】https://arxiv.org/abs/2108.13624 Towards Out-Of-Distribution Generalization: A Survey

4.4 【今日阅读】https://lobste.rs/s/wxqcul/project_with_single_11_000_line_code_file The project with a single 11,000-line code file

4.3 【今日阅读】https://www.youtube.com/clip/UgkxWCEmMJFW0-TvSMzcMEAHZcpt2FsVXP65 a little copying is better than a little dependency

4.2 【今日阅读】https://engineering.fb.com/2014/03/20/developer-tools/hack-a-new-programming-language-for-hhvm/ Every PHP programmer is familiar with day-to-day tasks that can be tricky or cumbersome. The code above is a great example of a common mistake where a method could unexpectedly be called on a null object, causing an error that wouldn’t be caught until runtime. Another example is a complex API, where developers may have a solid understanding of its semantics but still spend time looking up mundane method names in documentation.

4.1 【今日阅读】https://psalm.dev/articles/php-or-type-safety-pick-any-two We’ve used the techniques above to improve the type coverage of our codebase at Vimeo since introducing Psalm. In 2015, before Psalm was introduced, about 74% of the codebase was well-typed. In 2019, about 90% of the codebase is. That increase has come even as we’ve roughly doubled the size of the codebase

3.31 【今日阅读】https://stripe.com/blog/sorbet-stripes-type-checker-for-ruby Unfortunately we were starting to see Ruby come apart at the seams: new engineers found it hard to learn the codebase, and existing engineers were scared to make sweeping changes. Everyone faced a constant tradeoff: run the fast, local tests which might not catch many breakages, or run all the tests, even the slow ones. Ruby was becoming a source of friction more than a source of productivity.

3.30 【今日阅读】https://news.ycombinator.com/item?id=30822544 How to write a linter using tree-sitter in an hour

3.29 【今日阅读】https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html In fact, Eric Elliott, author of Composing Software and Programming JavaScript Applications goes as far as to say “abstraction is the process of simplifying code by finding similarities between different parts of the code and extracting shared logic into a named component (such as a function, module, etc...)” — i.e.: that abstraction is anti-unification. He then goes on to claim "The secret to being 10x more productive is to gain a mastery of abstraction." That sounds pretty impressive for a process which was first automated in 1970.

3.28 【今日阅读】https://zhuanlan.zhihu.com/p/463512291 《极简管理学》- 系统学习管理

3.27 【今日阅读】https://www.morling.dev/blog/whats-in-a-good-error-message/  As software developers, we’ve all come across those annoying, not-so-useful error messages when using some library or framework: "Couldn’t parse config file", "Lacking permission for this operation", etc. Ok, ok, so something went wrong apparently; but what exactly? What config file? Which permissions? And what should you do about it? Error messages lacking this kind of information quickly create a feeling of frustration and helplessness.

3.26 【今日阅读】https://machalliance.org/ The MACH Alliance presents and advocates for an open and best-of-breed enterprise technology ecosystem. The ecosystem technology is: Microservices based, API-first, Cloud-native SaaS and Headless.

3.25 【今日阅读】https://zhuanlan.zhihu.com/p/486693010 为什么真实世界的代码总是难以理解

3.24 【今日阅读】https://news.ycombinator.com/item?id=22090700 Dynamic type systems are not inherently more open

3.23 【今日阅读】https://juejin.cn/post/7077359097032474631 Go 1.18 新特性多模块工作区教程-让多模块开发变得简单

3.22 【今日阅读】https://lobste.rs/s/yz7yjv/penny_wise_cloud_foolish It’s actually been quite funny to see everything come full circle. A la carte pricing was a huge original selling point for cloud. Pay for what you use was seen as much more transparent, but that’s proven not to be the case since most orgs have no clue how much they use. Seeing more and more services pop up with flat monthly charges and how that’s now being claimed as more transparent than pay-as-you-go pricing has been an amusing 180.

3.21 【今日阅读】https://news.ycombinator.com/item?id=3101876 Steve's Google Platform rant https://gist.github.com/chitchcock/1281611

3.20 【今日阅读】https://okmij.org/ftp/ML/generalization.html How OCaml type checker works -- or what polymorphism and garbage collection have in common

3.19 【今日阅读】https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf in memory of Christopher Alexander

3.18 【今日阅读】https://mitchellh.com/writing/contributing-to-complex-projects Become a User; Build the Project; Learn the Hot-Path Internals; Read and Reimplement Recent Commits ; Make a Bite-sized Change

3.17 【今日阅读】https://dev.to/bytebodger/react-is-eating-itself-fga Outside of blogs and tutorial sites, you rarely see much code like above in "real" applications. And I don't mean just because the above example is small/simple. I mean, because React devs have been demonizing many of the simple concepts illustrated in this example. They keep picking at this basic framework until the result is hardly recognizable.

3.16 【今日阅读】https://monorepo.tools/ Everything you need to know about monorepos, and the tools to build them.

3.15 【今日阅读】https://blog.lawrencejones.dev/go-sum-type/ Hacking sum types with Go generics

3.14 【今日阅读】http://www.oilshell.org/blog/2022/03/backlog-arch.html Fine-grained static types, build-time composition, static linking, APIs, and version numbers ；Coarse-grained "waists", runtime composition, ABIs, IPC, and versionless protocols

3.13 【今日阅读】https://github.com/fabianlindfors/reshape Reshape is an easy-to-use, zero-downtime schema migration tool for Postgres. It automatically handles complex migrations that would normally require downtime or manual multi-step changes. During a migration, Reshape ensures both the old and new schema are available at the same time, allowing you to gradually roll out your application. It will also perform all changes without excessive locking, avoiding downtime caused by blocking other queries. 

3.12 【今日阅读】https://github.com/microsoft/mimalloc first-class heaps: efficiently create and use multiple heaps to allocate across different regions. A heap can be destroyed at once instead of deallocating each object separately.

3.11 【今日阅读】https://www.wave.com/en/blog/simple-architecture/ Wave is a $1.7B company with 70 engineers1 whose product is a CRUD app that adds and subtracts numbers. In keeping with this, our architecture is a standard CRUD app architecture, a Python monolith on top of Postgres. Starting with a simple architecture and solving problems in simple ways where possible has allowed us to scale to this size while engineers mostly focus on work that delivers value to users.

3.10 【今日阅读】https://yoshuabengio.org/2022/03/05/generative-flow-networks/ 结构源自于最小化“复现现象的程序”，通过压缩节省消耗

3.9 【今日阅读】https://www.dataorienteddesign.com/dodbook/ Data-Oriented design. The elusive destruction of object driven dogma. There are a lot of data-oriented talks out there, but for an intermediate programmer looking to avoid the pitfalls of the object-oriented mindset, it can be too hard to interpret and apply the lessons. This book is the perfect bridge between the advanced data-oriented material already out there, and the old ways of object-oriented programming. It sheds light on what Mike Acton means when he talks about everything is data and transforms. 

3.8 【今日阅读】https://zhuanlan.zhihu.com/p/475789952 用DDD(领域驱动设计)和ADT(代数数据类型)提升代码质量

3.7 【今日阅读】https://lobste.rs/s/byssgg/editing_stuff_prod It was either "edit in prod" or endure DAY LONG development cycles: make a change, wait 24 hours, come back tomorrow, and try it again. That's how broken it was.

3.6 【今日阅读】https://rushstack.io/ provide reusable tech for running large scale monorepos for the web

3.5 【今日阅读】https://martinfowler.com/articles/feature-toggles.html Release Toggles / Experiment Toggles / Ops Toggles / Permissioning Toggles

3.4 【今日阅读】https://www.youtube.com/watch?v=kPLGftyQ5ho&list=PLC2LZCNWKL9a7b7Ufx0ngo9xH_b8j9ZlA Functional Core, Imperative Shell

3.3 【今日阅读】https://riffle.systems/essays/prelude/ We’re exploring a new way to manage data in apps by storing all app state—including the state of the UI—in a single reactive database. Instead of imperatively fetching data from the database, the user writes reactive queries that update with fresh results whenever their dependencies change.

3.2 【今日阅读】https://embeddeduse.com/2022/03/01/visualising-module-dependencies-with-cmake-and-graphviz/ Visualising Module Dependencies with CMake and Graphviz

3.1 【今日阅读】https://arxiv.org/pdf/2010.12149.pdf Fuzzing is one of the most effective technique to identify potential software vulnerabilities. Most of the fuzzers aim to improve the code coverage, and there is lack of directedness (e.g., fuzz the specified path in a software).

2.28 【今日阅读】https://zhuanlan.zhihu.com/p/473388657 上 micro-frontend？大可不必。如果只是为了强制代码的模块化，完全不需要上 micro-frontend 这样的重型运行时方案，typescript+vite 在代码构建阶段就能把这个事给办了。

2.27 【今日阅读】https://www.thezdi.com/blog/2022/2/22/clang-checkers-and-codeql-queries-for-detecting-untrusted-pointer-derefs-and-tainted-loop-conditions  QL language reference - CodeQL CodeQL is the analysis engine used by developers to automate security checks, and by security researchers to perform variant analysis.

2.26 【今日阅读】https://martinfowler.com/articles/lean-inception/ An inception is an activity done at the start of a project to gather together the people involved and set a common direction and working style for the on-going work. The lean inception is a focused form of inception, which can be done in a single week. During this time we understand the key features and customers for the product, and build a canvas to formulate the characteristics of a Minimum Viable Product.

2.25 【今日阅读】https://blog.laurentcharignon.com/post/data-oriented-programming/ Yehonathan Sharvit popularized the term Data-Oriented Programming to encompass a set of principles that make it easier to grow a codebase. While none of those principles are novel, they are not mainstream in the industry, and they indeed make it far easier to work with code.

2.24 【今日阅读】https://blog.nelhage.com/post/why-sorbet-is-fast/ https://blog.nelhage.com/post/record-replay-in-sorbet/ Sorbet is a fast, powerful type checker designed for Ruby written in C++

2.23 【今日阅读】https://belkadan.com/blog/2022/02/Dynamic-Linking-and-Static-Linking/ Dynamic Linking Is Bad For Apps And Static Linking Is Also Bad For Apps

2.22 【今日阅读】https://jasonformat.com/islands-architecture/ render HTML pages on the server, and inject placeholders or slots around highly dynamic regions

2.21 【今日阅读】https://lobste.rs/s/nwjjfo/what_is_software_engineering Software engineering is what happens to programming when you add time and other programmers.

2.20 【今日阅读】https://turborepo.org/docs/features/remote-caching 这就是为啥 vercel 要收购 turborepo，通过 remote caching 加速 monorepo 的构建速度

2.19 【今日阅读】https://verdagon.dev/blog/seamless-fearless-structured-concurrency Seamless, Fearless, and Structured Concurrency

2.18 【今日阅读】https://www.youtube.com/watch?v=0yX8wGCzWNs Leverage vs. Autonomy in a Large Software System

2.17 【今日阅读】https://buttondown.email/hillelwayne/archive/why-you-should-read-data-and-reality/ we are not modeling reality, but the way information about reality is processed, by people

2.16 【今日阅读】https://brooker.co.za/blog/2022/01/31/deployments.html There are two hidden assumptions in the section above: problems happen (or become visible) some time after deployment, and that time is short enough that waiting between deployments will catch a significant proportion of problems. These assumptions lead to three of the biggest controversies in this space: how fast to move, how to measure speed, and the Friday question.

2.15 【今日阅读】https://gist.github.com/ttsiodras/e59c5ea4090a11f69073dcc10809d647 使用 affine type 类型检查表达业务逻辑上的状态约束 https://mariusschulz.com/blog/assertion-functions-in-typescript 使用 NonNullable 推断。共同点就是让开发者用更少的“标记工作量”达到静态检查业务逻辑约束的目的。

2.14 【今日阅读】https://www.ietf.org/archive/id/draft-iab-protocol-maintenance-05.html Protocol decay is a real pain. If you need to write an HTTP/1.1 proxy that is compatible with everything thrown at browsers, you can write 99% of the parser in a day, and then spend a year chasing WTF edge cases and horribly broken servers that you still have to entertain, because their garbage happens to work in browsers that accumulated decades of workarounds.

2.13 【今日阅读】https://pointersgonewild.com/2022/02/11/code-that-doesnt-rot/ I used to work in a deep learning research lab, and I’ve seen cases where researchers had published code just six months ago, but one or more of the dependencies on which they relied had since made breaking changes. That put us in the unfortunate position of having to troubleshoot someone else’s code. 

2.12 【今日阅读】https://itnext.io/reflecting-business-logic-rules-into-the-domain-models-using-typescript-part-1-e696773ae4ae 使用静态类型系统表达domain specific的运行时数据约束。所谓业务逻辑，就是一堆对数据的约束规则。把部分规则的教研从运行时转移到编译期用类型系统来表示有利于减轻代码阅读者的认知负担。

2.11 【今日阅读】https://fosdem.org/2022/schedule/event/go_errors/ Handle errors properly by thinking about their roles and domain within your application

2.10 【今日阅读】https://datastation.multiprocess.io/blog/2022-02-08-the-world-of-postgresql-wire-compatibility.html the wire protocols for open-source databases tend to be documented since it's just another part of an open-source system

2.9 【今日阅读】https://lobste.rs/s/if8hle/have_you_found_side_effects_problem_by Have you found side-effects a problem by increasing complexity in your code bases? 

2.8 【今日阅读】https://github.com/stepchowfun/tagref helps you maintain cross-references in your code. Tagref helps you maintain cross-references in your code. works with any programming language, and it respects your .gitignore file as well as other common filter files.

2.7 【今日阅读】https://solnic.codes/2022/02/02/rails-and-its-ruby-dialect/ Rails is not written in Ruby

1.30 【今日阅读】https://eli.thegreenplace.net/2022/rust-extension-traits-greppability-and-ides/ It's entirely possible that using a language like Rust without a sophisticated IDE is madness, and I'm somewhat stuck in the past. But I have to say, I do lament the loss of greppability. There's something very universal about being able to understand a project using only grep and the official documentation.

1.29 【今日阅读】https://www.steveonstuff.com/2022/01/27/no-such-thing-as-clean-code you need _____ code. It’s up to you to fill in that blank with words that describe what your project requires

1.28 【今日阅读】https://remix.run/blog/not-another-framework They don't use [the framework we're using], so everything I learned the last two years here doesn't even matter!

1.27 【今日阅读】https://catern.com/change_code.html There are some basic technical excuses one might give for why you aren't able to change the code

1.26 【今日阅读】https://www.brandons.me/blog/write-code-not-too-much-mostly-functions Eat food. Not too much. Mostly plants.

1.25 【今日阅读】http://akkartik.name/post/division-of-labor Ten years against division of labor in software

1.24 【今日阅读】https://www.fuzzingbook.org/ This book addresses this problem by automating software testing, specifically by generating tests automatically. Recent years have seen the development of novel techniques that lead to dramatic improvements in test generation and software testing. They now are mature enough to be assembled in a book – even with executable code.

1.23 【今日阅读】https://lobste.rs/s/bthzfk/webassembly_new_kubernetes webassembly: the new kubernetes?

1.22 【今日阅读】https://www.yuque.com/seeconf/2022/oywl8m 一种秒级安装 npm 的方式

1.21 【今日阅读】https://research.facebook.com/publications/holistic-configuration-management-at-facebook/ Facebook’s configuration end-to-end, including the frontend products, backend systems, and mobile apps.

1.20 【今日阅读】https://www.youtube.com/watch?v=J0p_thJJnoo Francois Chollet - Intelligence and Generalisation

1.19 【今日阅读】https://www.lei.chat/posts/compilers-and-irs-llvm-ir-spirv-and-mlir/#decoupling-and-modularizing-compilers The most important thing LLVM brings is the practice of decoupling and modularization. The plethora of wonderful libraries and tools built around LLVM is just a natural result of that.

1.18 【今日阅读】https://www.swift.org/documentation/api-design-guidelines/ swift API Design Guidelines

1.17 【今日阅读】https://zhuanlan.zhihu.com/p/456483953 本文主要面向前端 、Node.js 开发者，业务中使用 Monorepo 组织 应用 和 模块，抛砖引玉探讨下：怎样设计一个共享配置包（配置、类型、utils、枚举），同时在前端、Node.js、Vite 等项目中使用。UI 组件库怎么打包？组件库怎么支持服务端渲染（SSR）？有哪些好的最佳实践？怎么使用原生语言（Rust / C++ / Golang 等）编写的模块包？

1.16 【今日阅读】https://en.wikipedia.org/wiki/Self-determination_theory#Basic_psychological_needs Autonomy Competence Relatedness

1.15 【今日阅读】http://neugierig.org/software/blog/2022/01/rethinking-errors.html The lack of adequate hooks in the other direction, from the developer into the toolchain, is also an explanation for the existence of "lint" tools. In my experience tools named "lint" often end up being a grab-bag of "all the checks we wanted but that weren't enforced by the language already", which can vary from trivial guidelines all the way up to really important invariants.

1.14 【今日阅读】https://mp.weixin.qq.com/s/Ip20EvxqHKB5S0fXY80qpA DDD 的三层含义：协作、架构与实现

1.13 【今日阅读】https://dev.to/xba/data-oriented-programming-is-dope-ma2 Joe understands affirms that is "feelings" are due to « Data encapsulation has its merits and drawbacks: Think about the way you designed the Library Management System. According to DOP, the main cause of the complexity of systems and their lack of flexibility is because code and data are mixed together in objects »

1.12 【今日阅读】https://www.youtube.com/watch?v=sIBrFuzR3cs Martin Thompson On How To Manage Software Complexity

1.11 【今日阅读】https://lobste.rs/s/pydtol/dev_corrupts_npm_libs_colors_faker Commit package-lock.json like all of the documentation tells you to, and don’t auto-update dependencies without running CI.

1.10 【今日阅读】https://zhuanlan.zhihu.com/p/446376560 如果某个版本 (Sprint) 交付的东西, 并没有真实地投入到 Real World 里去使用, 去试错, 去收集反馈, 而只是给老板或者产品经理进行了演示, 那么他其实并不是一次合格的敏捷实践.

1.9 【今日阅读】https://bellmar.medium.com/hunting-tech-debt-via-org-charts-92df0b253145 Knowing where to look for problems by figuring out who reports up to whom

1.8 【今日阅读】https://engineering.backtrace.io/2021-12-19-bounded-dynamicism-with-cross-modifying-code/ we sometimes wish to toggle code that’s deep in performance-sensitive query processing loops, or tightly coupled with such logic. That’s when we rely on our dynamic_flag library.

1.7 【今日阅读】https://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory/ I believe that learning about these universal abstractions is the next step in software design. If you know design patterns, you have a vocabulary, but the details are still open to interpretation. If you know category theory, you have a better vocabulary. Just like design patterns, you have to learn these things, but once you've learned them, you've learned something that transcends a particular software library, a particular framework, a particular programming language.

1.6 【今日阅读】https://stackoverflow.blog/2022/01/03/favor-real-dependencies-for-unit-testing/ A functional core needs no dependency injection to support unit testing, because functions are always testable (being deterministic by definition). Only the imperative shell needs dependency injection to support unit testing.

1.5 【今日阅读】https://www.technovelty.org/code/why-symbol-visibility-is-good.html ELF provides for visibility attributes. Symbols can be default, protected, hidden or internal. Using these attributes, we can flag extra information for the dynamic loader so it can know which symbols are for public consumption, and which are for internal use only.

1.4 【今日阅读】https://building.nubank.com.br/why-we-killed-our-end-to-end-test-suite/ Most companies still believe that End-to-End Integration Tests are the best way to catch bugs. But they also experience a progressively slow down of value delivery due to these pain points that we uncovered during the assessment

1.3 【今日阅读】https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md The seed corpus is the user-specified set of inputs to a fuzz test which will be run by default with go test. These should be composed of meaningful inputs to test the behavior of the package, as well as a set of regression inputs for any newly discovered bugs identified by the fuzzing engine. This set of inputs is also used to “seed” the corpus used by the fuzzing engine when mutating inputs to discover new code coverage. A good seed corpus can save the mutation engine a lot of work (for example adding a new key type to a key parsing function).

1.2 【今日阅读】https://fasterthanli.me/articles/why-is-my-rust-build-so-slow 使用 https://ui.perfetto.dev/ 分析 rust 构建为啥这么慢

1.1 【今日阅读】https://buttondown.email/hillelwayne/archive/uncomfortable-truths-in-software-engineering/ A lot of these are really cynical, but they’re about the overall software engineering world, which consists of hundreds of thousands of companies and tens of millions of developers. We can still make things locally better, and that’s enough for me to keep trying.

12.31 【今日阅读】https://apenwarr.ca/log/20211229 If you wanted to pay someone to fix some software, you didn't want a gift. You wanted a company.

12.30 【今日阅读】https://mp.weixin.qq.com/s/jE9r3ovqr93m3KZ5qs-hnA 编程里的变量命名哲学

12.29 【今日阅读】http://www.erights.org/talks/thesis/markm-thesis.pdf When separately written programs are composed so that they may cooperate, they may instead destructively interfere in unanticipated ways. These hazards limit the scale and functionality of the software systems we can successfully compose. This dissertation presents a framework for enabling those interactions between components needed for the cooperation we intend, while minimizing the hazards of destructive interference.

12.28 【今日阅读】https://devtails.xyz/3-lines-of-code-shouldnt-take-all-day 3 Lines of Code Shouldn’t Take an Entire Day to Write

12.22 【今日阅读】https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/ Very often in programming we find ourselves needing access to some context object in many places in our code. Some examples of context objects: Arena allocator, String interner, Logging scope, Async executor, Capability object

12.21 【今日阅读】https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html &T is not an "immutable reference" or "const reference" to data of type T — it is a "shared reference". And &mut T is not a "mutable reference" — it is an "exclusive reference".

12.20 【今日阅读】https://matt-rickard.com/monorepos/ Monorepos have U-shaped utility. They are great for extremely small or extremely large organizations, and terrible for everything in between. Why's that?

12.19 【今日阅读】https://arnoldgalovics.com/microservices-in-production/ I’ve been having this thought on the back of my mind for a long time to write about why it’s often a bad idea to start with microservices for a brand new project.

12.18 【今日阅读】https://mp.weixin.qq.com/s/Nz0_z_TtVduBNnDgxySkfg 《聚合划分——从定性到定量》，它是DDD解空间的两大核心难题之一，这两大难题分别是限界上下文的划分与聚合的划分，今天的话题包含了三个部分，分别是理解聚合、不变量场景模式的矩阵分类和划分聚合的五大步骤

12.17 【今日阅读】https://rubyonrails.org/2021/12/15/Rails-7-fulfilling-a-vision Rails 7.0: It’s the fulfillment of a vision to present a truly full-stack approach to web development that tackles both the front- and back-end challenges with equal vigor. 

12.16 【今日阅读】https://go.googlesource.com/proposal/+/master/design/45713-workspace.md This proposal describes a new workspace mode in the go command for editing multiple modules. The presence of a go.work file in the working directory or a containing directory will put the go command into workspace mode. The go.work file specifies a set of local modules that comprise a workspace. When invoked in workspace mode, the go command will always select these modules and a consistent set of dependencies.

12.15 【今日阅读】https://github.com/reactwg/react-18/discussions/37 Streaming HTML lets you start emitting HTML as early as you’d like, streaming HTML for additional content together with the <script> tags that put them in the right places. Selective Hydration lets you start hydrating your app as early as possible, before the rest of the HTML and the JavaScript code are fully downloaded. It also prioritizes hydrating the parts the user is interacting with, creating an illusion of instant hydration.

12.14 【今日阅读】https://blogs.gentoo.org/mgorny/2021/11/07/the-future-of-python-build-systems-and-gentoo/ The Python ecosystem is changing constantly, and the packaging aspect of it is no different. The original distutils build system has eventually evolved into setuptools, and is now being subsumed by it. Setuptools seems to be moving in the direction of becoming yet another PEP 517 build backend and indiscriminately removing features.

12.13 【今日阅读】https://blog.klipse.tech/databook/2021/12/10/dop-link.html Principle #1: Separate code from data Principle #2: Represent data with generic data structures Principle #3: Data is immutable

12.12 【今日阅读】https://lobste.rs/s/xahswz/unix_philosophy_without_left_pad_part_2 Unix philosophy without left-pad, Part 2: Minimizing dependencies with a utilities package 

12.11 【今日阅读】https://mp.weixin.qq.com/s/TNm3m9fES6L9Ksg8XYwenw 换个角度，你会发现软件开发是历史上第一个把知识管理当做项目管理的核心管理方法，管理知识消费的流程，给大家提供足够多的交互场景。不可言说的知识是通过循环性、有节奏的反馈和故意设计的社交活动传播的。所以，这才是敏捷方法真正能够工作的原因，而不是那些所谓的形式上的工作时间。其中格外要强调结对编程

12.10 【今日阅读】https://codefaster.substack.com/p/is-systems-engineering-just-generalist Is systems engineering just generalist engineering?

12.9 【今日阅读】https://raku-advent.blog/2021/12/06/unix_philosophy_without_leftpad/ I’m kindof wondering if the right way to think about this is not so much an issue of the number or size of packages that are dependencies, but the number of maintainers who are dependencies. Ultimately, whether two independent functions are part of the same package or two different ones maintained by the same person is a fairly shallow question. The micropackage approach is bad mainly in that it makes maintainership harder to understand.

12.8 【今日阅读】https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/DesignCompositionPerformance.md Take things apart, Design like Bartok, Code like Coltrane, Langs and libs like instruments, Pursue harmony

12.7 【今日阅读】https://hacks.mozilla.org/2021/12/webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95/ WebAssembly and Back Again: Fine-Grained Sandboxing in Firefox 95

12.6 【今日阅读】https://eng.lyft.com/scaling-productivity-on-microservices-at-lyft-part-2-optimizing-for-fast-local-development-9f27a98b47ee Scaling productivity on microservices at Lyft (Part 2): Optimizing for fast local development

12.5 【今日阅读】https://reproducible-builds.org/ The motivation behind the Reproducible Builds project is therefore to allow verification that no vulnerabilities or backdoors have been introduced during this compilation process. By promising identical results are always generated from a given source, this allows multiple third parties to come to a consensus on a “correct” result, highlighting any deviations as suspect and worthy of scrutiny.

12.4 【今日阅读】https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.725.6063&rep=rep1&type=pdf Contemporary build systems provide limited efficiency because they lack support for expressing finegrained file dependencies

12.3 【今日阅读】https://lobste.rs/s/ypwgwp/tvix_we_are_rewriting_nix if you have to compute all dependencies beforehand, it both makes things slow and clashes with the way that certain packages want to be built. You have a lot of work to do before you can start to parallelize your build. Nix also very much has the “rewrite the entire upstream build system” problem that Bazel has.

12.2 【今日阅读】https://remix.run/ https://remix.run/docs/en/v1/guides/data-loading 对 react 组件进行存算分离

12.1 【今日阅读】https://martinfowler.com/articles/cant-buy-integration.html Despite a wide range of tools that aim to simplify wiring systems together, you can’t buy integration.

11.30 【今日阅读】https://iowiki.com/kdbplus/q_language_table.html Q 语言没有指针，但是有表。像 Q 语言，像 SQL，就是存算分离的编程模型

11.29 【今日阅读】https://developers.facebook.com/blog/post/2021/10/21/async-stack-traces-folly-improving-debugging-developer-lifecycle/ Async stack traces in folly: Improving debugging in the developer lifecycle

11.28 【今日阅读】https://danielbmarkham.com/weve-been-doing-this-the-wrong-way/ It is never going to work to describe how to create technology (program computers). We're always either too generic or extremely precise about things that are not applicable or not important. Instead of finding success, we need to talk much more about avoiding failure.

11.27 【今日阅读】https://stokoe.me/summary-hammock-driven-development/ What is Hammock Driven Development?

11.26 【今日阅读】https://zhuanlan.zhihu.com/p/437951945 代码审核的两种方向：不改变现有的写法（语法和api），让机器去适配现状，用机器代替人。改变写法（语法或者api），让机器提供更强的辅助

11.25 【今日阅读】https://www.tinyverse.org/ Lightweight is the right weight

11.24 【今日阅读】https://calpaterson.com/bank-python.html One of the slightly odd things about Minerva is that a lot of it is "data-first", rather than "code-first". This is odd because the majority of software engineering is the reverse. For example, in object oriented design the aim is to organise the program around "classes", which are coherent groupings of behaviour (ie: code), the data is often simply along for the ride.

11.23 【今日阅读】http://macqueenfest.cs.uchicago.edu/slides/harper.pdf 
The modules design featured a number of key ideas:
• Signatures (interfaces) and structures (basic modules).
• Fibered representation of families of modules.
• Dependent types for hierarchy and parameterization.
• Subtyping to mediate composition.
• Sharing constraints to express coherence conditions.
• Type classes for flexible reuse.
• Effect-sensitive abstraction (aka “generativity”).
A sharply original, and therefore socially disruptive, design

11.22 【今日阅读】https://guitarvydas.github.io/assets/2021-04-23-FDD/index.html Failure Driven Design

11.21 【今日阅读】https://luapower.com/philosophy Luapower doesn’t use semantic versioning. Each compatibility-breaking change is eagerly signaled with a tag change. This is the only honest choice, and if done without reserve, the tag number will show exactly how unstable an API really is.

11.20 【今日阅读】https://mp.weixin.qq.com/s/qxIs-FsbiPpMe465dUM56A 寻找合适的研发效能度量指标（下） 在软件研发过程中，一般会经过三个阶段或者说接手三种类型的项目：绿地项目、棕地(黄地)项目、红地项目，（下文使用: 绿地、黄地、红地与之对应并简化代表），好像一个软件系统的生命周期。通过识别项目类型来找到此类型合适的度量指标，这可能是一个快速高效的方案。

11.19 【今日阅读】https://rust-lang.github.io/api-guidelines/checklist.html API 设计良好需要考虑哪些点，这些需要注意的点为什么不是强制的呢？

11.18 【今日阅读】https://news.ycombinator.com/item?id=28283263 This is great in theory but in reality no such distinction exists. For example, is trying to read a missing file a failure of the code, or a failure of the user? It could easily be either, the developer hardcoded the file path wrong during development, or the user selected a wrong path in a CLI, ... the distinction between errors and exceptions must made by the call site, not the definition site. The code calling readFile() knows whether the error is recoverable or not. readFile() itself does not, so the same mechanism should be used for both errors and exceptions.

11.17 【今日阅读】https://github.com/arxanas/git-branchless/wiki/Tutorial 移除了 branch 概念之后的 git，以及类似的工具 https://github.com/arxanas/git-branchless/wiki/Related-tools

11.16 【今日阅读】https://dpc.pw/data-oriented-cleanandhexagonal-architecture-software-in-rust-through-an-example Data-oriented, clean&hexagonal architecture software in Rust – through an example project

11.15 【今日阅读】https://www.youtube.com/watch?v=2JGH_SWURrI Objects vs Values: Value Oriented Programming in an Object Oriented World

11.14 【今日阅读】https://eta.st/2021/03/08/async-rust-2.html closure 对于用类型来表达边界是巨大的挑战。为什么 closure 是必须的？closure 解决的是什么问题？

11.13 【今日阅读】https://matklad.github.io//2021/11/07/generate-all-the-things.html In this post, we’ll look at one technique from property-based testing repertoire: full coverage / exhaustive testing. Specifically, we will learn how to conveniently enumerate any kind of combinatorial object without using recursion.

11.12 【今日阅读】https://zhuanlan.zhihu.com/p/432199409 当我们切分模块的时候，要判断是为了服务 response latency，rollout latency还是development latency

11.11 【今日阅读】https://lobste.rs/s/hv7alh/designing_better_file_organization I think the filesystem as we know it is one of those OS concepts from the 1960s that really needs to be rethought. The more I work with and on databases, the more I realize that a filesystem is basically just a shitty database, with a fixed and limited schema and very poor durability for client data.

11.10 【今日阅读】https://web.eecs.utk.edu/~azh/blog/thisprojectwillonlytake.html This project will only take 2 hours

11.9 【今日阅读】https://www.slideshare.net/hitesh0141/control-system-design-60465720 A brief introduction to designing consideration during a control system and implementation in mechatronics system.

11.8 【今日阅读】https://news.ycombinator.com/item?id=29139902 当讨论一个api或者写法的运行时性能的时候，我们可以认为 representation 和 implementation 是两回事。通过优化引擎，是可以让 representation 很冗余，但是 implementation 仍然运行时很高效的。这是因为在实际让 cpu 去跑之前，可以有一个转换的过程。但是如果讨论的不是 cpu 运行时性能，而是人脑的“运行时”性能，也就是代码可读性的问题。则没有这么一个转换的过程。source code 即是 representation 也是 implementation。

11.7 【今日阅读】https://lobste.rs/s/wf3piq/npm_install_is_curl_bash It’s sad that most package tools (not just for javascript) are currently stuck in this artificial design dichotomy of allowing the library maintainer to run arbitrary code at build time with the full privileges of the user, and just not providing build-time programmability.

11.6 【今日阅读】https://blog.kronis.dev/articles/never-update-anything I think that this is the inevitable future of software. "Want support for older versions of stuff that you're stuck with because of organizational reasons beyond your control? Sure, pay us!" If you look at the pricing page, you actually see that you'd need to part with 3000 USD for that sort of a license

11.5 【今日阅读】https://zhuanlan.zhihu.com/p/424328840 这些梳理的过程，大部分是业务专家，以及系统架构师的范畴。他们的工作成果，将作为输入输出到技术团队实现。他们需要DDD，但他们并不用。

11.4 【今日阅读】https://www.zhihu.com/question/52311143/answer/133935378 为什么直接把API调用转到外面行不通：流量，出错控制，bug-to-bug兼容，什么是驱动

11.3 【今日阅读】https://github.com/rust-lang/miri An experimental interpreter for Rust's mid-level intermediate representation (MIR). It can run binaries and test suites of cargo projects and detect certain classes of undefined behavior。https://www.micahlerner.com/2021/10/31/rudra-finding-memory-safety-bugs-in-rust-at-the-ecosystem-scale.html 跨边界的类型检查是个有意思的问题

11.2 【今日阅读】https://fzakaria.com/2020/11/17/on-demand-linked-libraries-for-nix.html A key insight into the bootstrapping of an ELF binary in Linux is the interpreter, whose presence is there to help satisfy any dynamic linkage. 之前只知道 LD_PRELOAD，居然还有更狠的做法，直接替换 elf 里的 interpreter 路径。

11.1 【今日阅读】https://lobste.rs/s/rlxfdr/why_embedded_software_development_is An interesting dynamic I’ve observed as an embedded software engineer is that all developers are expected to understand the parts of the stack above them. So, the hardware designer is expected to also know firmware and software development. The firmware developer is expected to know software development. But don’t ever expect a software developer to know what a translation lookaside buffer is or how to reflash the board. In addition to that, if the bottom of the stack (e.g. the hardware) is broken, it’s impossible to do solid work on top of it. This is why talent and skill migrates towards the bottom of the stack, because that needs to be done right for everything else to even have a chance of working.

10.31 【今日阅读】https://mp.weixin.qq.com/s/PjNc7YLKT5JX_Obg2815Bg DDD 到底是银弹还是垃圾

10.30 【今日阅读】https://mp.weixin.qq.com/s/BHkq7klh902mxmWSCkkNMQ 当我们直接暴露 get/set, read/write 能力出去时，我们如何约束各个调用方 caller 以符合业务逻辑的方式去读写呢？直接暴露 read/write, get/set 这类数据层语义的操作，最终代码可能容易 unmaintainable，表面上的简单，实质上的简陋，可能在从0到1的时候开发速度快了，但迭代起来、改起来很容易陷入瓶颈，难以管理的随意 read/write 散落在代码库各个地方。我们如何找到代码库里的一个个 caller 调用方，逐个修改它们的读写逻辑呢？

10.29 【今日阅读】https://incrementalelm.com/opaque-types-let-you-think-locally/ Opaque Types Let You Think Locally 强制模块边界是静态类型检查的重要职能

10.28 【今日阅读】https://eli.thegreenplace.net/2021/a-comprehensive-guide-to-go-generate/ 宏，模板，代码生成。While Go does not have macros or other forms of metaprogramming, it's a pragmatic language and it embraces code generation with support in the official toolchain. 

10.27 【今日阅读】https://danluu.com/productivity-velocity/ Working on the right thing is more important than working quickly，Speed at X doesn't matter because you don't spend much time doing X，Thinking about productivity is bad and you should "live life"

10.26 【今日阅读】https://www.youtube.com/watch?v=B2JF2eAbQWo Programming as Architecture, Design, and Urban Planning

10.25 【今日阅读】https://scattered-thoughts.net/writing/reflections-on-a-decade-of-coding Reflections on a decade of coding

10.24 【今日阅读】https://blog.ploeh.dk/2021/10/18/readability-verification/  After I've written code, I'm a tapper. I'm in no position to evaluate whether the code I just wrote is readable. You need a listener (or, here: a reader) to evaluate whether or not sufficient information came across.

10.23 【今日阅读】https://lobste.rs/s/gqbpwd/release_early_release_often Cost of testing is the limiting factor for release frequency. If your test process is manual and expensive, you’ll be forced to release less often to amortize this cost. It usually pays off to automate testing, because there are many positives to frequent releases.

10.22 【今日阅读】https://www.destroyallsoftware.com/talks/boundaries This talk is about using simple values (as opposed to complex objects) not just for holding data, but also as the boundaries between components and subsystems.

10.21 【今日阅读】https://sethmlarson.dev/blog/2021-10-18/tests-arent-enough-case-study-after-adding-types-to-urllib3 Tests aren’t enough: Case study after adding type hints to urllib3

10.20 【今日阅读】https://embeddedartistry.com/blog/2019/04/01/what-can-software-organizations-learn-from-the-boeing-737-max-saga/ What can Software Organizations Learn from the Boeing 737 MAX Saga?

10.19 【今日阅读】https://danluu.com/learn-what/ One piece of advice I got at some point was to amplify my strengths. All of us have strengths and weaknesses and we spend a lot of time talking about ‘areas of improvement.’ It can be easy to feel like the best way to advance is to eliminate all of those. However, it can require a lot of work and energy to barely move the needle if it’s truly an area we’re weak in. Obviously, you still want to make sure you don’t have any truly bad areas, but assuming you’ve gotten that, instead focus on amplifying your strengths. How can you turn something you’re good at into your superpower?

10.18 【今日阅读】https://lobste.rs/s/qblewn/feedback_loops_are_bullshit Feedback Loops are Bullshit 

10.17 【今日阅读】https://mp.weixin.qq.com/s/3oa6pDQVrxKWI7IrN5ZKRQ React语境下前端DDD的思考

10.16 【今日阅读】http://www.inabr.com/news/13057 中国汽车工业协会SDV工作组携手60+成员单位联合发布《SDV服务API参考》规范，软件定义汽车

10.15 【今日阅读】https://minimalmodeling.substack.com/p/best-ideas-from-the-first-25-posts Minimal modeling substack is dedicated to in-depth discussion of all kinds of topics related to the database modeling

10.14 【今日阅读】https://lobste.rs/s/olwyqg/my_logging_best_practices_2020 日志最佳实践

10.13 【今日阅读】https://www.bilibili.com/video/BV1vQ4y1D7T6 领域驱动设计的价值与不足

10.12 【今日阅读】https://future.a16z.com/the-case-for-developer-experience/ Focus on the problem being solved, Focus on fitting into existing workflows, Focus on packaging and prioritization 

10.11 【今日阅读】https://mp.weixin.qq.com/s/L9wbfNG5fTXF5bx7dcgj4Q 将一个复杂的单体应用以功能或业务需求垂直的切分成更小的子系统，并且能够达到以下能力：子系统间的开发、发布从空间上完成隔离，子系统可以使用不同的技术体系，子系统间可以完成基础库的代码复用，子系统间可以快速完成通信，子系统间需求迭代互不阻塞，子应用可以增量升级，子系统可以走向同一个灰度版本控制，提供集中子系统权限管控，用户使用体验整个系统是一个单一的产品，而不是彼此的孤岛，项目的监控可以细化到到子系统

10.10 【今日阅读】https://owengage.com/writing/2021-10-09-good-tests-dont-change/ A common complaint about unit tests is the overhead that it takes to write and maintain them. I think the core reason for this is that people write tests that they keep needing to rewrite. Good tests don't change, even if data structures change.

10.9 【今日阅读】https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/ 20 Things I’ve Learned in my 20 Years as a Software Engineer

9.30 【今日阅读】https://danluu.com/in-house/ That’s pretty analogous to my experience working as an electrical engineer as well, where orgs that outsource functions to other companies without retaining an in-house expert pay a very high cost, and not just monetarily. They often ship sub-par designs with long delays on top of having high costs. “Buying” can and often does reduce the amount of expertise necessary, but it often doesn’t remove the need for expertise.

9.29 【今日阅读】https://github.blog/2021-08-11-githubs-engineering-team-moved-codespaces/ Yet for all our efforts, local development remained brittle. Collaborating on multiple branches across multiple projects was painful. 

9.28 【今日阅读】https://blog.jez.io/cli-code-review/ Files that have changed a lot in the past are likely to change in the future. I review these files with an eye towards what the next change will bring. Files that aren’t changed frequently are more likely to be brittle. Alternatively, it’s often the case that infrequently changed files stay unchanged because the change is better made elsewhere.

9.27 【今日阅读】https://dl.acm.org/doi/10.1145/227234.227243 The scientist builds in order to study; the engineer studies in order to build

9.26 【今日阅读】https://building.nubank.com.br/why-we-killed-our-end-to-end-test-suite/ Why We Killed Our End-to-End Test Suite

9.25 【今日阅读】https://nick.groenen.me/posts/rust-error-handling/ How should you structure error handling in a mature rust application?

9.24 【今日阅读】https://lobste.rs/s/sttul0/concept_files_folder_unfamiliar_modern Concept of files and folder unfamiliar to modern students

9.23 【今日阅读】https://mp.weixin.qq.com/s/iCpGXk_j_CWRLP1cKACFjA 沃尔沃目前的电子电气架构拥有100多个分布式的ECU，Patrik坦陈，这些方案都是以软硬件打包的方式从不同供应商那里采购的，沃尔沃主要承担了集成的工作。Patrik抱怨道，集成的工作量呈指数级增长，开发周期变得更长，再如此下去，汽车制造商将会失去竞争力。

9.22 【今日阅读】https://trishagee.com/2020/09/07/reading-code-is-a-skill/ 1. It's wrong to assume someone wrote unreadable code 2. It's a narrative of blame and it doesn't solve anything 3. Readable code is subjective

9.21 【今日阅读】https://hacker-recommended-books.vercel.app/category/0/all-time/page/0/0 40,000 HackerNews book recommendations

9.20 【今日阅读】https://zhuanlan.zhihu.com/p/412034775 现实的需求就是要这也集成那也集成，不可能让你独立正交，需求都是非常合理的，不是为了复杂而复杂

9.19 【今日阅读】https://lobste.rs/s/emyfhx/ditch_your_version_manager I feel like Nix/Guix vs Docker is like … do you want the right idea with not-enough-polish-applied, or do you want the wrong idea with way-too-much-polish-applied?

9.18 【今日阅读】https://github.com/joelparkerhenderson/monorepo-vs-polyrepo Monorepo means using one repository that contains many projects, and polyrepo means using a repository per project. This page discusses the similarities and differences, and has advice and opinions on both.

9.17 【今日阅读】https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/ 为了更好的支持 monorepo 解决文件过多的问题，git 提供了 sparse-checkout

9.16 【今日阅读】https://mp.weixin.qq.com/s/I-8ecySNbkiVCZCgITEYEw 结算系统设计方法

9.15 【今日阅读】https://martinfowler.com/articles/ship-show-ask.html Ship/Show/Ask is a branching strategy that combines the features of Pull Requests with the ability to keep shipping changes. Changes are categorized as either Ship (merge into mainline without review), Show (open a pull request for review, but merge into mainline immediately), or Ask (open a pull request for discussion before merging).

9.14 【今日阅读】https://www.youtube.com/watch?v=t705r8ICkRw&t=810s Elon Musk’s Five Steps to Optimize: - Question the Requirements - Delete Parts or Processes - Simplify - Accelerate - Automate

9.13 【今日阅读】https://neverworkintheory.org/2021/09/12/developer-testing-in-the-ide.html half of developers do not test at all; most programming sessions end without any test execution; 12% of tests show flaky behavior; test-driven development (TDD) is not widely practiced; and software developers only spend a quarter of their time engineering tests, whereas they think they test half of their time.

9.12 【今日阅读】https://mp.weixin.qq.com/s/hXRCbyKQl25ZshyJ9aXDag 理流程，定单据，填功能

9.11 【今日阅读】https://lobste.rs/s/a9ghhz/maintain_it_with_zig it’s not going to be possible to boil the ocean and throw out all existing unsafe software, but we can at least simplify things by using simpler and more direct dependency management in C/C++.

9.10 【今日阅读】https://medium.com/event-driven-utopia/a-visual-introduction-to-debezium-32563e23c6b8 A story-based introduction to understanding what Debezium is, how it is made of, and how it works in a real-world scenario

9.9 【今日阅读】https://mp.weixin.qq.com/s/XHrKSNxXKJtjawmJTfV2uA If tech leads are still engineers, where should their focus be if it isn’t writing code like it was beforehand? With these new demands, how should a lead prioritize what is most important, especially when demands stack up faster than they can be addressed and when it comes at the expense of your morning’s to-do list?

9.8 【今日阅读】https://www.pmi.org/learning/library/planning-process-indispensable-software-projects-7487 No battle is won according to the plan but no battle is won without a plan

9.7 【今日阅读】https://neverworkintheory.org/2021/08/29/software-development-waste.html Software Development Waste: Building the wrong feature or product, Mismanaging the backlog, Rework, Unnecessarily complex solutions, Extraneous cognitive load, Psychological distress, Waiting/multitasking, Knowledge loss, Ineffective communication

9.6 【今日阅读】https://neverworkintheory.org/2021/08/23/links-in-source-code-comments.html   Almost 10% of the links included in source code comments are dead. 没有静态类型检查的东西是靠不住的

9.5 【今日阅读】https://codecatalog.org/  Code Catalog is a collection of instructive code examples with annotations.

9.4 【今日阅读】https://eli.thegreenplace.net/2017/benefits-of-dependencies-in-software-projects-as-a-function-of-effort/   The more effort is spent on a project in terms of engineer-years, the less benefit dependencies have. For short, low-effort projects dependencies are hugely beneficial. For long, multi-person multi-year projects, not so much. In fact, for such longer-term projects the costs of dependencies begin to outweigh their benefits.

9.3 【今日阅读】https://news.ycombinator.com/item?id=28397238 As someone who's spent quite a bit of time thinking about authorization in GraphQL APIs, I think that the only viable option for authorization in GraphQL is node level authorization, especially if using the relay convention. You're forced to write every authorization check as a function of the relationship between the user and the subject at hand and it avoids accidentally leaking information

9.2 【今日阅读】https://mp.weixin.qq.com/s/TP7X_BmTmiETfxQ5cz4rPw 既然阿里SPU体系已经十分成熟，为什么闲鱼不使用现有淘系的SPU系统，要重新搭建一套体系呢？淘系的SPU系统经过多方共建已经可以达到新发商品实时落库，俨然成为庞大的数据体系，但结合闲鱼业务侧的诉求，我们面临的问题有哪些?

9.1 【今日阅读】https://lobste.rs/s/fear8c/why_we_don_t_do_daily_stand_ups_at_supercede Why We Don't Do Daily Stand-Ups at Supercede

8.31 【今日阅读】https://mp.weixin.qq.com/s/9X16ent8kNaUI64GC0xorw MBC方案解决的问题：核心业务既要高性能又要灵活性的问题，研发流程中产研配合效率低下的问题

8.30 【今日阅读】https://michaelfeathers.silvrback.com/system-personas-and-design-integrity One of the things that Dijkstra spoke about often was anthropomorphism—seeing code and systems as human-like; things with awareness and intention. The short story is: Dijkstra was against it.

8.29 【今日阅读】https://www.colorado.edu/artssciences-advising/resource-library/life-skills/the-feynman-technique-in-academic-coaching If you can’t explain it to a six-year-old, you don’t understand it yourself.

8.28 【今日阅读】https://danluu.com/why-benchmark/ If anything, because measurement is, like writing, not generally valued, it's much easier to find high ROI measurement projects than high ROI building projects.

8.27 【今日阅读】https://blog.jim-nielsen.com/2021/useful-and-usless-code-comments/ Unfortunately, many comments are not particularly helpful. The most common reason is that comments repeat the code: all of the information in the comment can easily be deduced from the code next to the comment.

8.26 【今日阅读】https://news.ycombinator.com/item?id=28304420 	We Hire Old People

8.25 【今日阅读】https://mp.weixin.qq.com/s/nqPAMe92d7WJrwFf2ogG3A 在企业中，度量数据的获取一定要实现自动化，如果你的度量数据都依赖于工程师的手工录入来获取，一方面工程师会对此种工作模式十分反感，另一方面会让后续的度量分析完全失去意义，因为人工录入的数据或多或少已经存在了很多失真，而且很多数据的录入时间是有很大参考价值的，如果数据不是实时获取，而是人工填充的，那么数据本身就失去了度量的意义。

8.24 【今日阅读】https://mp.weixin.qq.com/s/h9zIg2e8iHn3qgxlUGObbQ 优秀的度量体系设计对目标会有很强的正向牵引作用，不恰当的度量体系往往会引发一场“腥风血雨”。

8.23 【今日阅读】https://burak-kirazli.medium.com/an-alternative-conditional-compilation-approach-with-modern-c-e94b46100a29 An Alternative Conditional Compilation Approach with Modern C++

8.22 【今日阅读】https://slack.engineering/data-lineage-at-slack/ To ensure that lineage is ingested for dashboards, we leverage audit tables that track dashboard usage. If a dashboard pulled data in the last 24 hours, we consider it “active” and send a request to the lineage service.

8.21 【今日阅读】https://jvns.ca/blog/confusing-explanations/ why do I find all these explanations so confusing? I decided to try and find out! I came up with a list of 12 patterns that make explanations hard for me to understand. For each pattern I’ll also explain what I like to do instead to avoid the issue.

8.20 【今日阅读】https://lobste.rs/s/v8iqgb/configuration_configuration_files_is Programmers love generality, and to some degree don't want to do language design, so I understand the eternal appeal of some universal language for program configurations.  

8.19 【今日阅读】https://www.youtube.com/watch?v=lgZ7Cxt5uIU Teaching Great Programmers: Is it possible? By whom? How?

8.18 【今日阅读】http://probcomp.csail.mit.edu/software/bayesdb/ find me the 10 colleges most like MIT and Harvard with regards to graduates’ median income, but admissions rates over 10%，find me radiation measurements from the Safecast.org project that are most likely to be errors and/or legitimate anomalies，generate some EEG measurements we might expect for a child in Bangladesh at age 3 years of age, given all the other EEG measurements we have observed so far，what genetic markers, if any, predict increased risk of suicide given a PTSD diagnosis? and how confident can we be in the amount of increase, given uncertainty due to statistical sampling and the large number of possible alternative explanations?

8.17 【今日阅读】https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da  图示 fake/mock/stub 的区别

8.16 【今日阅读】https://github.com/google/highway/blob/master/g3doc/highway_intro.pdf  为了让代码支持更多种的 CPU，无法对 SIMD 的 vector 长度做硬编码。又指望不上编译器能短时间内提供高质量的优化。C++ 这种方便制作 eDSL 的语言就可以发挥威力了

8.15 【今日阅读】https://www.youtube.com/watch?v=FL8CxUSfipM 打开汽车厂商的黑盒，使用开源软件控制你家的汽车自动驾驶，现已支持100多种型号

8.14 【今日阅读】https://css-tricks.com/bem-101/ This is the main reason we end up with bloated code bases, full of legacy and unknown CSS that we daren’t touch. We lack the confidence to be able to work with and modify existing styles because we fear the consequences of CSS’ globally operating and leaky nature. 

8.13 【今日阅读】https://livebook.manning.com/book/the-programmers-brain/welcome/v-5/ When you read code, solve a problem, or write code, your brain is working all the time. While the brain plays a significant role in programming, I have found that most programmers do not understand how the brain processes code.

8.12 【今日阅读】https://ryougifujino.com/post/10 模块化的重要性：大多数关心软件架构的人都会强调模块化对一个良好系统的重要性。如果我面临着对一个模块化程度很低的系统做一个小小的改动，我就必须了解它的几乎所有内容，因为即使是一个小改动也可能波及代码库的许多部分。然而，有了良好的模块化，我只需要了解一两个模块的代码，以及另几个模块的接口，而可以忽略剩下的。这种降低我理解难度的能力，就是为什么随着系统的发展，值得在模块化上投入如此多的努力的原因。

8.11 【今日阅读】https://jesseduffield.com/Beyond-Coupling-And-Cohesion/ Here we have two microservices which always need to change at the same time, meaning that unlike in the previous example, we would never have one service being updated on its own. This typically means that for each change, A needs to pass B some different parameters, or call a new endpoint. And that means B needs to remain backwards compatible with A for the brief gap between their two deployments. The solution to this problem is to just combine the two microservices into one! Slightly less micro but still provides a service.

8.10 【今日阅读】https://zhuanlan.zhihu.com/p/397697428 还有另一种，NV的一些调度逻辑（比如control codes），也从硬件转移到了软件。这个应该是因为编译器具有更全局的视野，可以更好的做依赖分析和指令调度，同时也简化硬件设计，节省面积。

8.9 【今日阅读】https://basecamp.com/shapeup/3.4-chapter-13#work-is-like-a-hill 如何让开发者上报更多的信息来支撑改进？让他们把 uncertainty 表达出来？work is like a hill 是一种可以考虑的管理手段。其核心是用6个离散的刻度来代替精确的百分比，度量 uncertainty 而不是 #% lines of code written 。因为时间不是花在“写”代码上，而是花在 reduce uncertainty 上。 

8.8 【今日阅读】https://news.ycombinator.com/item?id=28098578 又在讨论 framework 和 library 的区别是啥

8.7 【今日阅读】https://mp.weixin.qq.com/s/YgRnFCgtI1sSmT5U5KkIcg 以神经系统来说，当我们伸手去摸一个水壶，在被水壶烫的那一刻发生了什么呢？手马上就弹回来，半秒钟后大脑才意识到烫。这里面包含两套决策机制，手上的基层神经系统瞬间就已经做出了反应——让手快速离开，同时信息被上报到中央的决策机构——大脑，大脑半秒钟后才意识到被烫，并做出更加宏观、高层次的决策。因此，比尔所采用的“可生存系统模型”强调，一个有效的复杂系统是中央领导和局部主观能动性的有机结合。

8.6 【今日阅读】http://mikehadlow.blogspot.com/2012/05/configuration-complexity-clock.html?m=1 从代码，到配置，到规则引擎，到dsl。然后回到原点

8.5 【今日阅读】https://blog.deref.io/unix-and-microservice-platforms/ Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. Often, this philosophy is further shortened to just the first sentence.

8.4 【今日阅读】https://mp.weixin.qq.com/s/QfbIioMrFNpnmvp_GycKVA 帐，是结果，是固定的，稳定的。即便是账错了，也要留痕迹红冲更正的。单据，代表了过程，代表了状态和数量的不稳定，一直到过账（审核）后才稳定下来。现在，稳定态的对象，和一个不稳定的对象，强行绑在了一起，麻烦由此而起。

8.3 【今日阅读】https://mp.weixin.qq.com/s/ciYlvX6tQ7TaF0_5rRYN-Q 对抗软件系统复杂性②：全局一致，统一隐喻

8.2 【今日阅读】https://news.ycombinator.com/item?id=28017289 I require myself to retype any examples, stack overflows, and so on in the process of learning. Along the way, I get a handle on the patterns of the language. And if I'm learning in an IDE, the autocomplete suggestions start to hint at the other functions within libraries, etc.

8.1 【今日阅读】https://stackoverflow.blog/2021/07/28/700000-lines-of-code-20-years-and-one-developer-how-dwarf-fortress-is-built/ 700,000 lines of code, 20 years, and one developer: How Dwarf Fortress is built

7.31 【今日阅读】https://fluxml.ai/FastAI.jl/dev/docs/fastai_api_comparison.md.html  对比 fast.ai 的 julia 和 python 版本，高层中层底层，这三层的 api 是如何分工的，语言的特性是如何影响 api 的设计？

7.30 【今日阅读】https://copyconstruct.medium.com/distributed-tracing-weve-been-doing-it-wrong-39fc92a857df If you truly have a mind-bogglingly complex distributed system, then no one single person can have a complete understanding of the system in their head at any given time. debugging is a tool that’ll help reduce the search space, so that engineers can zero in on a subset of dimensions (services/users/hosts etc.) that are of interest to the debugging scenario at hand.

7.29 【今日阅读】http://yosefk.com/blog/10x-more-selective.html working on 'products' values more such things as 'completeness' at the expense of 'efficiency'.
Working on 'service' your work must reasonably fulfill the customers use cases; most often at the expense of 'completeness'; As a consultant you might try to minimize the effort that has to be put into a task, while completing the customers spec.

7.28 【今日阅读】https://zhuanlan.zhihu.com/p/393041071 几年前还经常听到有人说觉得CUDA写的程序不够高效，会自己逆向构建一个SASS汇编器来撰写汇编kernel，还可以说CUDA这一层存在leaky abstraction。这一两年，这样做的人已经越来越少了。将CUDA视为一个不存在leaky abstraction的抽象层应该不会太有争议。随着时间的推移，NV的软件栈系统里的leaky abstractions会不会越来越少呢？

7.27 【今日阅读】https://mp.weixin.qq.com/s/opCnSlnKYhrNkjP8xN-EGA 在大仓模式和主干开发的模式下， 我们可以更方便地主动去为其他组的项目提交代码，例如修复缺陷或实现我们所需的新功能。这个组可能是姐妹组，也可能是相隔甚远的项目组。我们认为作者对代码有太强的归属感，即有强烈的领地意识，对开放协作文化有害。隐藏代码或不允许别人触碰自己编写的代码是反模式。允许别人修改，自己由 CR 做最终决定，是更为开放和有效的合作模式。

7.26 【今日阅读】https://buttondown.email/nelhage/archive/papers-i-love-gg/ a tool called gg, which is designed to allow users to use cloud computation — including “function-as-a-service” systems like Amazon Lambda — to outsource everyday computation (such as software builds) from their laptops to the cloud, without requiring users to provision or manage a standing compute cluster.

7.25 【今日阅读】http://www.oilshell.org/blog/2021/07/spolsky.html Classic Blog Posts by Joel Spolsky

7.24 【今日阅读】https://lobste.rs/s/wzb4gl/modeling_mutual_friendship the two-row model seems to be substantially simpler for ad-hoc manual and analytic queries, if you need those (and it’s a nice thing to have). The single-row model will quickly become tedious or would again require pre-processing.

7.23 【今日阅读】https://lobste.rs/s/howzf7/planning_estimating_large_scale Planning & estimating large-scale software projects

7.22 【今日阅读】https://www.snellman.net/blog/archive/2021-07-21-monorepo-atomic/ A monorepo misconception - atomic cross-project commits

7.21 【今日阅读】http://paulbuchheit.blogspot.com/2009/01/communicating-with-code.html you should consider spending less time talking, and more time prototyping, especially if you're not very good at talking or powerpoint. Your code can be a very persuasive argument.

7.20 【今日阅读】https://lobste.rs/s/9n7aic/what_i_learned_from_software_engineering What I learned from Software Engineering at Google。Automate common tasks，Stubs and mocks make bad tests，Small frequent releases，Upgrade dependencies early, fast, and often，Expert makes everyone’s update

7.19 【今日阅读】https://news.ycombinator.com/item?id=27863822 The database ruins all good ideas 

7.18 【今日阅读】https://zhuanlan.zhihu.com/p/375634204 表面上 tensorflow 和 pytorch 是静态和动态之争，内里还是一个分工问题。tf就是一个大公司的产品，不同的团队来负责不同的东西，每个团队做的东西，在他们内部都说逻辑自洽的，木有任何问题，一旦配合起来就是非常痛苦。而pytorch则是走的理念+ 社区的道路。pytorch只捡取了最核心的部分，实现了，剩下的东西都交给了社区。这一点非常好，一是之前的代码可以复用，二是社区自动票选出最好的实现。这个过程已经熟练到惊人的程度了。

7.17 【今日阅读】https://lobste.rs/s/pp5blh/why_are_graph_databases_not_more_popular 为什么图数据库没有更流行？

7.16 【今日阅读】https://github.com/esrlabs/josh Combine the advantages of a monorepo with those of multirepo setups by leveraging a blazingly-fast, incremental, and reversible implementation of git history filtering.

7.15 【今日阅读】https://www.youtube.com/watch?v=l5NeBQ_3bS8 Building Knowledge in an Interdisciplinary World

7.14 【今日阅读】https://chriswarrick.com/blog/2018/07/17/pipenv-promises-a-lot-delivers-very-little/ Pipenv: promises a lot, delivers very little

7.13 【今日阅读】https://littlegreenviper.com/miscellany/testing-harness-vs-unit/ Compared to unit tests, a test harness is a [usually] simple standalone application that incorporates the system under test, and presents a user interface. Since it is for testing, it may expose internal metrics and allow the user to access parts of the code that are usually hidden. I prefer using test harnesses. Here’s why.

7.12 【今日阅读】https://www.sicpers.info/2021/07/my-proposal-for-scaling-open-source-dont/ the companies are hyper-concerned about “growth” because when you’ve got a billion users, your shareholders want to know where the next hundred million are coming from, not the next twenty

7.11 【今日阅读】https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems Every line of code written comes at a price: maintenance. To avoid paying for a lot of code, we build reusable software. The problem with code re-use is that it gets in the way of changing your mind later on.

7.10 【今日阅读】https://16bpp.net/blog/post/automated-testing-of-a-ray-tracer/ Unit Testing vs. Integration Testing (for a Ray Tracer)

7.9 【今日阅读】https://erikbern.com/2021/07/07/the-data-team-a-short-story.html 数据团队应该怎么弄才合理

7.8 【今日阅读】https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and A given module often gets changed because it is the easiest module to change, rather than the best place for the change to be made. In the end, what defines a module is what pieces of the system it will never responsible for, rather what it is currently responsible for.

7.7 【今日阅读】https://github.com/hwayne/lets-prove-leftpad/ 通过简单的例子来学习“形式化证明”有什么用，是如何工作的

7.6 【今日阅读】https://lobste.rs/s/8msejg/notes_on_structured_concurrency_go Treat threads like stack variables. That’s it. That’s the tweet. Don’t let them outlive the function they’re spawned from, and everything gets a whole lot easier to reason about. 

7.5 【今日阅读】把软件的行为想象成一个基于帧的动画。我们用不同的表述状态的方式（ http://canonical.org/~kragen/memory-models/ ）来表述一个静态的帧。然后需要描述第一帧，如何变化到第二帧。按照时序，一步步描述是一种方式。直接表述帧与帧之间的映射关系，是另外一种方式。重读 Out of tarpit （ http://curtclifton.net/papers/MoseleyMarks06a.pdf ） 感受一下这两种表述方式的区别。

7.4 【今日阅读】https://medium.com/hackernoon/leaky-by-design-7b423142ece0 In some cases, the problem with the abstraction and the cause of leakiness is that the abstraction tries to abstract or hide “the wrong thing”. 

7.3 【今日阅读】https://mp.weixin.qq.com/s/KiWiaLyaBd79MrgCRwAjxw 现在环顾四周，我们会发现日常生活中常常会用到一些非常复杂的系统：智能手机、计算机、打印机、汽车、电视、烤面包机…… 虽然我们自己很难自行从零制造这样的一个机器，但是不论这些设备或系统多么复杂，我们都可以正常使用它们来完成日常所需的工作。 那为什么会有 抽象泄漏（Leaky Abstractions）？

7.2 【今日阅读】https://principles.dev/p/ Principle-Driven Engineering (PDE) is a methodology that uses Principles to rapidly share understanding and behavior in teams and technology organizations, making them more productive.

7.1 【今日阅读】https://www.rainforestqa.com/blog/accessible-quality Asking Developers to Do QA Is Broken. Here’s Why We Built a Product to Let Anyone Own QA.

6.30 【今日阅读】https://blog.csdn.net/significantfrank/article/details/85785565 COLA 作者会出来怼星环（ https://mp.weixin.qq.com/s/AeUfHAcWvAs4HmyMX0rkCA ）其实并不奇怪

6.29 【今日阅读】http://suckless.org/philosophy/ Most hackers actually don't care much about code quality. Thus, if they get something working which seems to solve a problem, they stick with it. If this kind of software development is applied to the same source code throughout its entire life-cycle, we're left with large amounts of code, a totally screwed code structure, and a flawed system design. This is because of a lack of conceptual clarity and integrity in the development process.

6.28 【今日阅读】https://www.youtube.com/watch?v=gCWtkvDQ2ZI What are conflicts, really? When defs "compete for a name" A totally artificial problem. Rethinking anything and everything about programming

6.27 【今日阅读】https://lobste.rs/s/63eb9g/when_rewrite I find it’s useful to go through the mental exercise of “how would I do this differently if I were to start from scratch?” and then separately think about “is there a more direct way to get from here to there?”

6.26 【今日阅读】https://elisabethirgens.github.io/notes/2021/06/code-reviews/ Pull requests are an improvement on working alone. But not on working together. Required reviews makes me sad

6.25 【今日阅读】https://zhuanlan.zhihu.com/p/383129585 不能满足需求，为了满足多个业务的复用需求，不得不把组件修改到很别扭的程度，参数失控，版本无法管理

6.24 【今日阅读】https://downtimeproject.com/podcast/7-lessons-from-10-outages/ 7 种常见的 outage 原因，以及大量事故案例复盘

6.23 【今日阅读】https://instadeq.com/blog/posts/past-futures-of-programming-general-magic-telescript/ 读的时候让我又想起了 smalltalk 的 seaside http://book.seaside.st/book/fundamentals/anchors/callbacks 为什么一个 object 只能存在于一个进程，锁死在一个设备里，为什么不能让 object 在进程之间迁移，一会在这里执行，一会在那里执行。如果鸿蒙能够促使万物互联，将来参与交互的设备可能不仅仅是手机和服务器，也许目前以单个设备为中心的编程世界观也会被动摇，迎来 seaside 模式的复兴。

6.22 【今日阅读】https://www.slideshare.net/galleman/architectured-centered-design Architectured Centered Design

6.21 【今日阅读】https://mp.weixin.qq.com/s/2dUYEYvlizLPiou792HVKA 什么是业务，什么是业务架构？

6.20 【今日阅读】https://factorio.com/blog/post/fff-366 The only way to go fast is to go well

6.19 【今日阅读】https://testing.googleblog.com/2016/08/hackable-projects.html?m=1 google 分享的 hackable projects 三篇系列文章

6.18 【今日阅读】https://ocw.mit.edu/high-school/humanities-and-social-sciences/godel-escher-bach/video-lectures/ https://godel-escher-bach.fandom.com/wiki/G%C3%B6del,_Escher,_Bach_Wiki the book expounds concepts fundamental to mathematics, symmetry, and intelligence. Through short stories, illustrations, and analysis, the book discusses how systems can acquire meaningful context despite being made of "meaningless" elements. It also discusses self-reference and formal rules, isomorphism, what it means to communicate, how knowledge can be represented and stored, the methods and limitations of symbolic representation, and even the fundamental notion of "meaning" itself.

6.17 【今日阅读】https://buttondown.email/hillelwayne/archive/comment-the-why-and-the-what/ I disagree: No matter how self-documenting the code is, comments help a lot with understanding stuff. Whenever I go back to an old project, I find the comments far more useful to reorient myself than my code or my tests. Here are some cases where adding the “what” is really helpful.

6.16 【今日阅读】https://henrikwarne.com/2021/06/15/on-comments-in-code/ 关于代码里的注释

6.15 【今日阅读】https://lobste.rs/s/dg3cku/two_different_views_what_decoupled_code Two Different Views of What Decoupled Code Means

6.14 【今日阅读】https://thenewstack.io/how-culture-impacts-technology-choice-a-review-of-netflixs-use-of-microservices/ How Culture Impacts Technology Choice: A Review of Netflix’s Use of Microservices

6.13 【今日阅读】https://spectrum.ieee.org/cars-that-think/transportation/advanced-cars/software-eating-car Even low-end vehicles are quickly approaching 100 ECUs and 100 million of lines of code as more features that were once considered luxury options, such as adaptive cruise control and automatic emergency braking, are becoming standard.

6.12 【今日阅读】https://lobste.rs/s/tcmn0u/don_t_feed_thought_leaders A Hedgehog had one big idea like free-market capitalism (or nordic model capitalism or demand-side economics), which they used as a lens to look at many issues. Foxes were the opposite of hedgehogs. They had complicated advice and were skeptical of even their own predictions. Tetlock also found that foxes were less likely to be famous because contingent advice is harder to explain in a sound bite.

6.11 【今日阅读】https://rtpg.co/2021/06/07/changes-checklist.html 数据库表结构迁移，逐步检查清单

6.10 【今日阅读】https://lobste.rs/s/euswuc/glue_dark_matter_software 胶水代码：软件的黑物质

6.9 【今日阅读】https://www.hillelwayne.com/post/cleverness/ We talk about cleverness as if it’s Just Bad, such as “clever code is harder to debug”. That’s going too far. Cleverness can lead to faster, safer, even clearer code. I’m going to call this class of cleverness “insightful” to distinguish them.

6.8 【今日阅读】https://www.youtube.com/watch?v=FKFu78ZEIi8 CQRS 的创造者 Greg Young 分享 Why Event Sourced Systems Fail

6.7 【今日阅读】https://zhuanlan.zhihu.com/p/378232554 当把《分析模式》生搬硬套到外汇业务

6.6 【今日阅读】https://blog.codingnow.com/2017/06/overwatch_ecs.html 浅谈《守望先锋》中的 ECS 构架

6.5 【今日阅读】https://lobste.rs/s/fuqmad/faster_you_unlearn_oop_better_for_you_your The faster you unlearn OOP, the better for you and your software

6.4 【今日阅读】https://zhuanlan.zhihu.com/p/25169261 《噢，你的代码像一坨翔。然后呢？》4年前我写了这篇文章，列举了我尝试过的各种药方。4年后，这是我给的答案 https://mp.weixin.qq.com/s/UtBkJYpQHIvRQ_AQnzxxMw

6.3 【今日阅读】https://lobste.rs/s/mtatsi/unix_shell_programming_next_50_years The copy of FreeBSD that I run locally has a prototype of two things that I keep meaning to share more publicly: content negotiation for pipes and multiple streams for the tty.

6.2 【今日阅读】https://juejin.cn/post/6968647527239254029 如果你在负责（或作为 team leader 在跟进）前端组的组件库开发。并且，你的组件库提供给多个产品线在使用；并且，你发现组件库工作出现很多的“魔改”，“版本分化”，而且你对这件事情很介意；那么本分享可能适用于你；

6.1 【今日阅读】https://inertiajs.com/ Inertia.js lets you quickly build modern single-page React, Vue and Svelte apps using classic server-side routing and controllers.

5.31 【今日阅读】https://itnext.io/things-to-think-before-enabling-feature-toggle-in-your-application-91880373a0ed Define the type of toggle and life expectancy before starting to implement.

5.30 【今日阅读】https://www.inf.ed.ac.uk/teaching/courses/pi/2016_2017/phil/tufte-powerpoint.pdf PowerPoint 每页的低分辨率，导致信息需要在时间维度堆叠。人类的硬件却是在所有信息都能在空间上同时呈现时工作更佳。把什么信息装入同一个屏幕内很关键。

5.29 【今日阅读】https://wiki.c2.com/?ConceptualIntegrity In 1995, Brooks still hasn't changed his mind: I am more convinced than ever. ConceptualIntegrity is central to product quality. Having a system architect is the most important single step toward conceptual integrity...after teaching a software engineering laboratory more than 20 times, I came to insist that student teams as small as four people choose a manager, and a separate architect.

5.28 【今日阅读】http://www.blackwellpublishing.com/content/bpl_images/content_store/sample_chapter/9780631233152/garud-001.pdf We have shown thus far that complex systems will evolve from simple systems much
more rapidly if there are stable intermediate forms than if there are not. The resulting complex forms in the former case will be hierarchic.

5.27 【今日阅读】https://zhuanlan.zhihu.com/p/375062873 如果一个好主意50年了还没有落地，那它也不是那么好的主意

5.26 【今日阅读】https://zhuanlan.zhihu.com/p/374398693 而真正有经验的工程师，一定会在开始写代码之前先思考将要写作的代码，哪些是用于定义业务对象的，哪些是用于控制数据流的，哪些是为了完成界面渲染的，哪些是为了完成用户交互的等等。而这些思考，用一种思想来概括就是“分层思想”或者叫“Layered Architecture”。

5.25 【今日阅读】http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/32713.pdf Joshua Bloch on How to Design a Good API and Why it Matters

5.24 【今日阅读】https://www.austincc.edu/sondg/handouts/micro/whyfirms.pdf Why Firms? 1. Lower transactions costs 2. Economies of scale 3. Economies of team production

5.23 【今日阅读】https://web.archive.org/web/20140415191114/http://www.threeriversinstitute.org/blog/?p=104  An element that solves several problems will only be partly changed. This is riskier and more expensive than changing a whole element because first you need to figure out what part of the element should be changed and then you need to prove that the unchanged part of the element is truly unchanged. Cohesive elements, replaced in total, don’t incur these costs. 这就是 kent beck 阐述的他的定义下的 cohesion 能够降低成本的原理

5.22 【今日阅读】https://docs.planetscale.com/concepts/nonblocking-schema-changes PlanetScale is a new hosted database provider. Where it differs from the rest though is in it's branching/merging features for migrations. It allows developers to create branches off of the main database schema and then apply their schema changes in isolation.

5.21 【今日阅读】https://www.youtube.com/watch?v=3gib0hKYjB0 听 kent beck 讲什么是耦合什么是内聚。我的观后感 https://zhuanlan.zhihu.com/p/373962759

5.20 【今日阅读】https://cpojer.net/posts/dependency-managers-dont-manage-your-dependencies https://cpojer.net/posts/rethinking-javascript-infrastructure Dependency Managers Don’t Manage Your Dependencies

5.19 【今日阅读】https://mp.weixin.qq.com/s/3zNwbV-x_LJbFHIPBVr-mQ 饿了么交易系统5年演化血泪史

5.18 【今日阅读】https://www.youtube.com/watch?v=QnmRpHFoYLk A Path to Better Programming • Robert "Uncle Bob" Martin & Allen Holub

5.17 【今日阅读】https://spectrum.ieee.org/computing/it/inside-hidden-world-legacy-it-systems The best way to deal with legacy IT is to never let IT become legacy. Since 2015, DARPA has funded research aimed at making software that will be viable for more than 100 years. The Building Resource Adaptive Software Systems (BRASS) program is trying to figure out how to build “long-lived software systems that can dynamically adapt to changes in the resources they depend upon and environments in which they operate,” according to program manager ­Sandeep Neema.

5.16 【今日阅读】https://thehosk.medium.com/software-development-is-a-losers-game-fc68bb30d7eb Software development is a loser’s game

5.15 【今日阅读】https://www.dddheuristics.com/ We all use heuristics (even if we haven’t articulated them to others) to discover, understand, explore, create, modify, or extend complex software systems. Billy Vaughn Koen, in Discussion of the Method: Conducting the Engineer’s Approach to Problem Solving, defines a heuristic as, “anything that provides a plausible aid or direction in the solution of a problem but is in the final analysis unjustified, incapable of justification, and potentially fallible.

-Rebecca Wirfs-Brock

5.14 【今日阅读】https://scs-architecture.org/index.html The Self-contained System (SCS) approach is an architecture that focuses on a separation of the functionality into many independent systems, making the complete logical system a collaboration of many smaller software systems.

5.13 【今日阅读】https://www.reddit.com/r/programming/comments/g7tjzn/preventing_software_rot/ Preventing Software Rot

5.12 【今日阅读】https://zhuanlan.zhihu.com/p/371279371 重新梳理了一下《代码防腐》，拆出了5个方向。123大致对应了之前的consistency, autonomy, feedback，45两点是新加入的。

5.11 【今日阅读】https://medium.com/dunnhumby-data-science-engineering/dealing-with-the-inevitability-of-software-entropy-is-software-equilibrium-attainable-7d5d277dc689 Dealing With The Inevitability of Software Entropy — Is Software Equilibrium Attainable?

5.10 【今日阅读】https://mp.weixin.qq.com/s/bY2s7wjfggSt77kj8exYLQ 微服务的灾难

5.9 【今日阅读】https://medium.com/@casual.evil52/events-in-entity-component-systems-22dc5107ed81 和微服务一样，ECS 在游戏领域也是类似的存在。大家鼓吹用了 ECS 之后，你的逻辑就解耦了。但是需求就不知道咋实现了。

5.8 【今日阅读】https://mp.weixin.qq.com/s/SjU1DbsXcBD-2DJt9z65zg 在日常工作中我观察到，面对老系统重构和迁移场景，有大量代码属于流水账代码，通常能看到开发在对外的API接口里直接写业务逻辑代码，或者在一个服务里大量的堆接口，导致业务逻辑实际无法收敛，接口复用性比较差。所以本文主要想系统性的解释一下如何通过DDD的重构，将原有的流水账代码改造为逻辑清晰、职责分明的模块。

5.7 【今日阅读】https://eavoices.com/2010/11/28/the-art-of-change-fractal-and-emergent/ The Art of Change: Fractal and Emergent

5.6 【今日阅读】https://blog.marcgravell.com/2021/05/is-era-of-reflection-heavy-c-libraries.html?m=1 用 partial method 作为集成的 api，链接用户的代码和框架生成的代码

4.30 【今日阅读】https://netflixtechblog.com/building-and-scaling-data-lineage-at-netflix-to-improve-data-infrastructure-reliability-and-1a52526a7977 Freedom & Responsibility (F&R) is the lynchpin of Netflix’s culture empowering teams to move fast to deliver on innovation and operate with freedom to satisfy their mission. Central engineering teams provide paved paths (secure, vetted and supported options) and guard rails to help reduce variance in choices available for tools and technologies to support the development of scalable technical architectures.

4.29 【今日阅读】https://news.ycombinator.com/item?id=26969364 What's Accenture?

4.28 【今日阅读】https://lobste.rs/s/9cyjyb/please_systematically_enforce_your Please, Systematically Enforce Your Constraints. “internationalization”, “activity history”, “dark mode” and “right to be forgotten” are behavior-constraining features. Building them in large part involves adding new constraints that must apply across existing and future behaviors in your app. Today’s software tools and techniques are designed mostly around behavior-adding features, not constraintful features.

4.27 【今日阅读】https://netflixtechblog.com/the-netflix-cosmos-platform-35c14d9351ad The Netflix engineering culture famously relies on personal judgement rather than top-down control. Software developers have both freedom and responsibility to take risks and make decisions. None of us have the title of Software Architect

4.26 【今日阅读】https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/ This is why code reuse is so hard. This is why everybody on your team has a different function they like to use for splitting strings into arrays of strings. They write their own function because it’s easier and more fun than figuring out how the old function works.

4.25 【今日阅读】https://earthly.dev/blog/brown-green-language/ The reason that [ developers ] think the old code is a mess is because of a cardinal, fundamental law of programming: It’s harder to read code than to write it. by Joel Spolsky

4.24 【今日阅读】https://www.red-gate.com/simple-talk/opinion/opinion-pieces/the-framework-myth/ The Framework Myth

4.23 【今日阅读】https://zhuanlan.zhihu.com/p/366859735 随意能部署一套是注定无法稳定的，多租户才是终极解决办法

4.22 【今日阅读】https://mp.weixin.qq.com/s/Q20M4CRATcQEzlD1rqKMEw 如何避免引入一堆小模块，且不确定之间的版本兼容性？import 再 export 是唯一的解法吗？

4.21 【今日阅读】https://stitcher.io/blog/what-event-sourcing-is-not-about Starting with event sourcing

4.20 【今日阅读】https://www.youtube.com/watch?v=SiGFGW1X3Y0 Objective reality and subjective consciousness are two sides of the same (information theoretic) coin.

4.19 【今日阅读】https://zhuanlan.zhihu.com/p/365278966 软件 A 依赖 软件 B 和 C， 而软件 B 依赖 X 的 v1 版本，软件 C 则依赖 软件 X 的 v2 版本，这时候如果用户需要安装软件 A，那么包管理器应该帮他安装 X 的 v1 版本还是 v2 版本呢？这个问题我们可以称之为“菱形依赖”问题。

4.18 【今日阅读】https://medium.com/swlh/problems-with-micro-frontends-8a8fc32a7d58 We were too focused on size and not focused on our problems. In our case, some argued for dividing our product between the two large and distinct domains, with little overlap, matching our lines of business. Others argued for cutting a level deeper, splitting each 15–20 times to make everything really ‘micro’.

4.17 【今日阅读】https://lobste.rs/s/lyeekg/read_from_databases_write_apis 从数据库读，往api写。读写分开

4.16 【今日阅读】https://www.amazon.com/gp/product/0133903354/ 5.10 The Matrix: Solve It or Dissolve It
Half the world is so used to matrix management as to take the scheme for granted. The other half just thinks it’s bizarre.

4.15 【今日阅读】http://www.kamilgrzybek.com/design/modular-monolith-primer/ If you don’t need to distribute your system (and most people don’t) and your system is non-trivial – maybe a Modular Monolith with Domain Centric Design in mind will be for you.

4.14 【今日阅读】https://danielbmarkham.com/personality-models-management-by-statistic-and-better-ai/ Personality Models, Management-By Statistic, And Better AI

4.13 【今日阅读】https://github.com/temporalio/temporal/ uber 的那个工作流引擎 Cadence 的作者出来搞了家创业公司

4.12 【今日阅读】https://news.ycombinator.com/item?id=26759680 the increased communication overhead will consume an ever-increasing quantity of the calendar time available. When n people have to communicate among themselves, as n increases, their output decreases and when it becomes negative the project is delayed further with every person added.

4.11 【今日阅读】https://mitpress.mit.edu/books/software-design-flexibility SICP 作者的新书《Software Design for Flexibility - How to Avoid Programming Yourself into a Corner》

4.10 【今日阅读】https://news.ycombinator.com/item?id=26727878 Adding is favoured over subtracting in problem solving

4.9 【今日阅读】https://media.defense.gov/2018/Oct/09/2002049591/-1/-1/0/DIB_DETECTING_AGILE_BS_2018.10.05.PDF 美国国防部：DIB Guide: Detecting Agile Bullshit。The purpose of this document is to provide
guidance to DoD program executives and acquisition professionals on how to detect software projects that are really using agile development versus those that are simply waterfall or spiral development in agile clothing (“agile-scrum-fall”).

4.8 【今日阅读】https://news.ycombinator.com/item?id=2787525 The reason I hate frameworks (even things like Django which is very easy to get started with) is that, at some point, I'm asked to re-learn a different way of solving a problem that I've already solved in the past.

4.7 【今日阅读】https://huhao.dev/posts/a7c771dd/ 8x Flow 业务建模法（二）：再看什么是业务逻辑

4.6 【今日阅读】https://huhao.dev/posts/2932e594/ 8x Flow 业务建模法（一）：你能分清业务和领域吗？

4.5 【今日阅读】https://blog.nelhage.com/post/some-opinionated-sql-takes/ Honestly, migrations might be my biggest pet peeve with SQL databases. They’re just way harder and riskier than they need to be. Let’s look at two areas where they bug me.

4.4 【今日阅读】https://blog.nelhage.com/post/computers-can-be-understood/ 没有捅不破的黑盒，只要功夫下得深，技术栈有多深就可以走多深

4.3 【今日阅读】https://www.gabrielpascua.com/books/2020/02/11/fundamentals-of-software-architecture There are no wrong answers in architecture, only expensive ones.

4.2 【今日阅读】https://mkaszubowski.com/2020/09/17/modular-software-design-mistakes.html Modular software design - 10 common mistakes

4.1 【今日阅读】https://hub.packtpub.com/why-dont-you-have-a-monorepo/ Why don’t you have a monorepo?

3.31 【今日阅读】https://m.youtube.com/watch?v=3wyd6J3yjcs The Silver Bullet Syndrome

3.30 【今日阅读】http://blog.lusis.org/blog/2011/10/18/rollbacks-and-other-deployment-myths/ Rollbacks are a myth
Yes, it’s true. You can never roll back. You can’t go back in time. You can fake it but understand that it’s typically more risky to rollback than rolling forward. Always be rolling forward.

3.29 【今日阅读】https://mkaszubowski.com/2021/03/27/modular-design-read-models-background-jobs.html Modular design patterns: Read models for background jobs

3.28 【今日阅读】https://www.informit.com/articles/article.aspx?p=1833567 低风险软件发布的4个原则

3.27 【今日阅读】https://blog.koehntopp.info/2021/03/24/a-lot-of-mysql.html “gitops” ain’t gonna happen soon. We are going to see AIP operations (“ass-in-produxction”) for quite some time, I am afraid. And that is why I wear black and yell at the cloud.

3.26 【今日阅读】https://www.red-gate.com/blog/zero-downtime-database-deployments-are-a-lie Many people assume that building proficiency at database development and operations leads to the ability to attain "zero downtime deployments." In this post I share why "zero downtime" is a problematic goal, and what a better approach looks like.

3.25 【今日阅读】https://paradox1x.org/2009/11/worth-repeating/ Worth Repeating: Rob Pike “Data dominates.” and Frederick Brooks “Representation is the Essence of Programming”

3.24 【今日阅读】https://paulhammant.com/2021/02/19/software-development-current-reality-tree-starter-pack/ Current Reality Trees (CRT)  看起来是一种很好的由表及里的思维呈现方式。每个爱吐槽的人，都可以画一副自己的。

3.23 【今日阅读】https://chriskiehl.com/article/thoughts-after-6-years Software development topics I've changed my mind on after 6 years in the industry

3.22 【今日阅读】https://news.ycombinator.com/item?id=24229325 I am really hating working in the current state of the industry right now. I am used to writing robust, clear, well-tested, and easy to maintain systems.
The job right now seems just stitching AWS services together, and spending the rest of your time debugging and putting out fires.

3.21 【今日阅读】https://www.infoq.com/presentations/Reflection-OOP-Social/ 听 James Coplien 聊聊 OO 的历史

3.20 【今日阅读】https://news.ycombinator.com/item?id=26511754 
An abstraction (OAM)
On the top of an abstraction (K8s Custom Object specification)
On the top of an abstraction (Kubernetes, et.al.)
On top of another abstraction (Containers)
On top of another abstraction (VMs)

3.19 【今日阅读】https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/ All non-trivial abstractions, to some degree, are leaky.

3.18 【今日阅读】https://stackoverflow.com/questions/648246/at-what-point-does-a-config-file-become-a-programming-language At what point does a config file become a programming language?

3.17 【今日阅读】https://dl.acm.org/doi/pdf/10.1145/3454122.3454124 MYTH: One productivity metric can tell us everything

3.16 【今日阅读】https://paulhammant.com/2019/11/20/environment-hell/ This would be after 1995, and should have ended before 2015, really. 然而并没有

3.15 【今日阅读】https://vimeo.com/43536416 其实老爷子说的就是要分开 IS 和 DOES。我一直都说 what you do defines who you are，其实就是说没有必要对 IS 进行建模，只要 DO 的事情是在不同的 context 下的，其实没有必要因为物理世界中是同一个object，就是在代码中的同一个 object

3.14 【今日阅读】https://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf Why Most Unit Testing is Waste By James O Coplien

3.13 【今日阅读】https://www.youtube.com/watch?v=agT6B2X1zt0 Why I Wouldn't Use MicroServices by Fred George

3.12 【今日阅读】https://mp.weixin.qq.com/s/DuD1dUNuM12S6ByR0dkEAw 软件开发团队的脓包：皇帝的新装、口号党、鸵鸟、废话迷

3.11 【今日阅读】https://www.youtube.com/watch?v=d38VVZqSylU http://nealford.com/downloads/Stories_Every_Developer_Should_Know_by_Neal_Ford.pdf the more reusable something is, the less usable it is.

3.10 【今日阅读】https://hbr.org/2020/11/how-apple-is-organized-for-innovation Apple’s functional organization is rare, if not unique, among very large companies. It flies in the face of prevailing management theory that companies should be reorganized into divisions and business units as they become large. But something vital gets lost in a shift to business units: the alignment of decision rights with expertise.

3.9 【今日阅读】https://lobste.rs/s/mxcmxg/abstraction_is_okay_magic_is_not TL;DR Magic is different. It feels different.

3.8 【今日阅读】https://perl.plover.com/yak/design/ The "design patterns" movement in software claims to have been inspired by the works of architect Christopher Alexander. But an examination of Alexander's books reveals that he was actually talking about something much more interesting.

3.7 【今日阅读】https://medium.com/serverless-transformation/is-serverless-the-end-of-ops-devops-vs-noops-nativeops-7997889f9a9c NativeOps: the push for architectural quality and empowerment of developer autonomy in a cloud-native world.

3.6 【今日阅读】https://news.ycombinator.com/item?id=17499137 Goodbye Microservices: From 100s of problem children to 1 superstar

3.5 【今日阅读】https://news.ycombinator.com/item?id=10337763 The microservices cargo cult

3.4 【今日阅读】https://relay.dev/docs/en/thinking-in-relay 一句话 reducing the coupling

3.3 【今日阅读】https://www.youtube.com/watch?v=C78QF3gaYnM 不是所有的“业务”都是围绕 database 的，比如 uber 无人车上跑的“业务集群”就不是，其本质上的分工原则会有不同吗？

3.2 【今日阅读】https://en.wikipedia.org/wiki/Information_hiding 信息隐藏的词条解释

3.1 【今日阅读】https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction duplication is far cheaper than the wrong abstraction

2.28 【今日阅读】https://alan-lang.org/the-turing-completeness-problem.html The "business logic" should not be written in Turing complete languages, but rather composable languages based on simple type theory. So the "business logic" would be limited in what it can do to compromise the system. And then it should be deployed on the execution platform, which is a different concern altogether.

2.27 【今日阅读】http://www.wirfs-brock.com/allen/posts/1018 Software Diagrams Aren’t Always Correct and That’s OK

2.26 【今日阅读】https://news.ycombinator.com/item?id=26247052 Module boundaries vs service boundaries Remember, ChromeOS is a monolith. iOS is a monolith. Your team is probably much smaller than either of those teams. You simply don't need to juggle a lot of microservices to get what you want.

2.25 【今日阅读】https://macwright.com/2021/02/23/one-way-to-represent-things.html I claim that most simple programming environments are simple because their datatypes are simple, not because their control flow or statements or expressions are simple.

2.24 【今日阅读】https://news.ycombinator.com/item?id=26217911 A Data Pipeline Is a Materialized View

2.23 【今日阅读】https://news.ycombinator.com/item?id=26211721 Choose Boring Technology https://news.ycombinator.com/item?id=26212563 Choose Exciting Technology

2.22 【今日阅读】https://neilkakkar.com/why-is-naming-things-hard.html Why Is Naming Things Hard?

2.6 【今日阅读】2/6 ~ 2/21 休刊，祝大家节日快乐。

2.5 【今日阅读】https://lobste.rs/s/2ijdt3/reasoning_about_code_is_scam 所谓的让代码更可读，就是一场骗局

2.4 【今日阅读】http://thinking-forth.sourceforge.net/ Many software engineering principles discussed here have been rediscovered in eXtreme Programming, including (re)factoring, modularity, bottom-up and incremental design. Here you'll find all of those and more. Published first in 1984, it could be among the timeless classics of computer books, such as Fred Brooks' The Mythical Man-Month and Donald Knuth's The Art of Computer Programming.

2.3 【今日阅读】https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html The Clean Architecture

2.2 【今日阅读】https://domk.website/blog/2021-01-31-cult-of-best-practise.html 最佳实践 => 货物崇拜

2.1 【今日阅读】https://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321 Making Software: What Really Works, and Why We Believe It

1.31 【今日阅读】https://zhuanlan.zhihu.com/p/82586450 中台的”中“是什么含义，我曾经提出了三个可能的解释。目前来看，Central Platform 的含义是最正确的。

1.30 【今日阅读】https://news.ycombinator.com/item?id=11348798
Holy moly-- is-positive-integer/index.js:
```js
  var passAll = require('101/pass-all')
  var isPositive = require('is-positive')
  var isInteger = require('is-integer')

  module.exports = passAll(isPositive, isInteger)
```
  
1.29 【今日阅读】https://teamtopologies.com/ 把团队分为 stream-aligned, enabling, complicated subsystem, platform 四种类型，从而给团队之间的协作划分为 X-as-a-Service, Facilitating, Collaboration 三种。如果实际的协作强度超过了预期，说明团队边界切分有问题。

1.28 【今日阅读】https://blog.bitsrc.io/microfrontends-survey-evaluation-d2af7eade306 How Micro Frontends are being Implemented in 2020: A Survey

1.27 【今日阅读】https://erlang-in-anger.com/ It is first and foremost a collection of tips and tricks to help understand where failures come from, and a dictionary of different code snippets and practices that helped developers debug production systems that were built in Erlang.

1.26 【今日阅读】https://arstechnica.com/science/2020/01/a-deep-dive-into-the-apollo-guidance-computer-and-the-hack-that-saved-apollo-14/ 阿波罗14的热修复故事

1.25 【今日阅读】https://lobste.rs/s/shgt0b/have_historical_changes_development Have historical changes in development practices / tooling degraded the quality of programmers?

1.24 【今日阅读】https://www.hillelwayne.com/post/crossover-project/what-we-can-learn/ The most common answers I heard fell into two broad categories: 1) we can prepare more, and 2) we can care more.

1.23 【今日阅读】https://www.hillelwayne.com/post/crossover-project/we-are-not-special/ 
1. Traditional engineering is best done in a Waterfall style, while software is best done in an Agile one.
2. Trad engineering is very predictable, while software is very unpredictable.
3. Engineering is mostly about manufacture, while code is mostly about design, because “the code is the design”.
4. Trad engineering is much more rigorous than software engineering is.
5. Software moves much faster than traditional engineering does.

1.22 【今日阅读】https://news.ycombinator.com/item?id=25823907 Are We Really Engineers?

1.21 【今日阅读】https://qntm.org/clean It's probably time to stop recommending Clean Code

1.20 【今日阅读】https://dev.to/bosepchuk/why-i-cant-recommend-clean-architecture-by-robert-c-martin-ofd Clean Architecture failed to meet my expectations on a number of fronts. Despite Mr. Martin's obvious passion for the topic, Clean Architecture is poorly organized, lacks examples, and is silent on working with existing systems. The author missed a major opportunity to teach us when and how to apply these lessons to our own systems. Let me explain.

1.19 【今日阅读】https://www.thoughtworks.com/insights/blog/microservices-evolutionary-architecture Because each service is decoupled from all other services (at the structural level), replacing one microservice with another resembles swapping one Lego brick for another.

1.18 【今日阅读】https://m.signalvnoise.com/the-majestic-monolith/ Ruby on Rails 的作者 DHH 《The Majestic Monolith》

1.17 【今日阅读】http://ergoso.me/computer/science/github/software/evolutionary/couplings/2014/12/10/evsrc-evolutionary-couplings-reveal-poor-software-design.html Evolutionary couplings between files reveal poor design choices in software architecture

1.16 【今日阅读】https://stackoverflow.blog/2020/12/07/measuring-developer-productivity/ 开发者的效率可以被度量吗?

1.15 【今日阅读】https://www.microsoft.com/en-us/research/publication/hints-for-computer-system-design/ 名言有云“任何计算机科学的问题都可以通过增加一层间接性来解决”，这句话就是本文作者说的

1.14 【今日阅读】https://alisterbscott.com/2015/02/06/intentionally-disposable-software/ Programmers don't delete enough production code. It's because we build software systems that are way too complex, have features that no-one uses and are built to last way too long. 

1.13 【今日阅读】https://news.ycombinator.com/item?id=23375193 1985年的 https://news.ycombinator.com/item?id=10014530 1972年的 https://news.ycombinator.com/item?id=12568863 1967年的，从三个不同的角度来描述 programming 这份工作

1.12 【今日阅读】为什么软件开发很困难，按时间循序 http://jeremymikkola.com/posts/2021_01_01_why_software_development_is_hard.html 2006年的 http://curtclifton.net/papers/MoseleyMarks06a.pdf  1986年的 http://worrydream.com/refs/Brooks-NoSilverBullet.pdf
