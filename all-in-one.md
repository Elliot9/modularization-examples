# 如何不 Review 每一行代码，同时保持代码不被写乱

本文的读者

* 你为代码总是被同事们写乱了而苦恼，但是又无法 Review 每一行代码
* 你要开发一个 SaaS，实现各种复杂功能的组合，但是又不能像互联网公司一样堆很多人来开发微服务
* 你模仿过主流的微服务，DDD 等做法，但并没有达到理想的效果，不介意尝试一些非主流的新办法

本文的目标是以尽可能浓缩的篇幅提供可模仿的步骤来达成“如何不 Review 每一行代码，同时保持代码不被写乱”的目标。总共三步

* 第一步：不要拆分代码仓库，不要拆微服务。Monorepo is all you need，Feature Toggle is all you need。
* 第二步：管控集成类需求的代码审查：主板加插件。
* 第三步：管控规范型需求的代码审查：独家垄断。

# 第一步：不要拆分代码仓库，不要拆微服务

拆分微服务以及代码仓库的缺点

* 利用组织边界来强化代码的分工边界会导致将来调整阻力很大。我们对于代码应该如何组织的认识是随着新需求不断调整的。不要轻易动用“组织架构”这样的核武器来达成小目标。
* 拆分了代码仓库之后不利于在编译期做集成，做集成后的整体验证。即便运行时集成有万般好处，也没有必要丧失掉编译期集成的选项。
* 跨代码仓库的代码阅读，开发时的辅助和检查都会变困难。
* 微服务控制变更风险的灰度边界是固化的，也就是微服务的大小。切得越细，每次变更的东西就越少，风险就越小。这不够灵活。
* 微服务的弹性边界是固化的，如果某种视频编辑需要特别多的内存，我们希望独立伸缩，就得把这部分代码切割出来变成一个独立的微服务。

拆分微服务和代码仓库相比单体架构，最重要的目标是减少分支冲突，控制发布变更的风险。但是拆分微服务和代码仓库并不是最佳的解决方案。Monorepo + Feature Toggle 是更好的解决方案。

* Monorepo：所有的代码都在一个仓库里。这样就不存在不同模块的仓库有不同的版本问题。大家都是统一的一个版本。升级线上系统的过程拆分成：部署+发布，两个步骤。部署的时候，整个 Monorepo 的代码都部署到目标机器上了，但并不代表发布了。
* Feature Toggle：特性开关来精确控制哪些逻辑分支被发布出去。这样部署就和发布解耦了。要灰度多少比例，可以精确控制。要一个特性开关的两个版本的逻辑分支共存，也可以实现。

使用 Monorepo + Feature Toggle 可以提供所有拆分微服务达成的目标，同时克服以上微服务拆分带来的缺点

* 通过目录结构来控制代码所有权。你可以要求这个目录下的代码必须经过你的 Code Review。调整目录结构比调整代码仓库容易得多，比调整组织架构要容易得多。
* 可以保持编译期集成这个选项。
* 可以更容易实现开发时辅助和检查工具，可以很方便地阅读跨模块的代码
* 变更风险更小，不仅仅开关回滚很快，而且开关可以灵活地定向灰度，而且一个开关的控制范围大小也可大可小，粒度非常灵活。
* 弹性边界更灵活，不需要因为要独立扩缩容，就得把代码切分出去

经常听说的一个说法是最终是要拆分成微服务，多仓库的。单体应用单仓库只是一个过度形态。这会导致我们认为为啥步一步到位呢。但事实并非如此，微服务和多仓库并不一定适合所有人。你可以用 Monorepo + Feature Toggle 用一辈子。

具体如何实践 Monorepo + Feature Toggle 按照 https://www.branchbyabstraction.com/ 和 https://trunkbaseddevelopment.com/ 的指导去做就可以了。

# 第二步：管控集成类需求的代码审查

当我们把代码都放一个代码仓库里之后，立即要面临的问题是代码不会写乱么？你怎么控制什么代码写在哪里？每一行代码写之前都来问你，每一行代码写完了都需要你来 Review 么？

所以，我们需要一种强制检查代码写在了正确的位置的自动化机制。这个机制就叫“依赖管理”。对应常见的编程语言

* 如果是 TypeScript，这个叫 package.json
* 如果是 Golang，这个叫 go.mod
* 如果是 Java，这个叫 POM.xml
